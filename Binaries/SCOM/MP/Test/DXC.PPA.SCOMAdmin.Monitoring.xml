<!--
Date: Oct 6, 2020
Current state: MP is working.
Issues/Memory joggers:
- Last bit I was working on was the mgreport and getting the SQL version info for ops/dw databases.
- I discovered it's tricky running a query that gets info from 2 sql servers so I commented out code that uses it.
- Thinking of redoing agent and gw mgcount part because I don't like how all the data is presented on one line.
- Disable alert when agent/gw has no failovers - not done yet, need to review.
-->

<ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<Manifest>
<Identity>
<ID>DXC.PPA.SCOMAdmin.Monitoring</ID>
<Version>1.0.0.51</Version>
</Identity>
<Name>DXC.PPA.SCOMAdmin.Monitoring</Name>
<References>
<Reference Alias="Windows">
<ID>Microsoft.Windows.Library</ID>
<Version>7.5.8501.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="System">
<ID>System.Library</ID>
<Version>7.5.8501.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="SystemCenter">
<ID>Microsoft.SystemCenter.Library</ID>
<Version>7.0.8433.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="Health">
<ID>System.Health.Library</ID>
<Version>7.0.8433.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
</References>
</Manifest>
<TypeDefinitions>
<EntityTypes>
<ClassTypes>

<!--**************************************** WINDOWS PROPERTIES ****************************************-->

<ClassType ID="DXC.PPA.SCOMAdmin.WindowsClass" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.LocalApplication" Hosted="true" Singleton="false" Extension="false">
<Property ID="OperatingSystem" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="Product" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentMGCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentMGFailovers" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="HealthServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="HealthServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="CertificateExpiryDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ADIntegration" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMInstalled" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSForwarderServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSForwarderServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="TLS12" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAWorkspaceCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAWorkspaces" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAProxyUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAProxyUsername" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ComputerType" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConfigServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConfigServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DataAccessServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DataAccessServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="OpsDbName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="OpsDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DWDbName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DwDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollector" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="RMS" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayMGCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayMGFailovers" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AuthenticationMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DefaultServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ApmAdvisorUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ApmDiagnosticsUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerDwDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerDWDBName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="SRSInstance" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleURInstallDate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
</ClassType>
</ClassTypes>
</EntityTypes>
<ModuleTypes>

<!--**************************************** WINDOWS DISCOVERY DATA SOURCE MODULE ****************************************-->

<DataSourceModuleType ID="DXC.PPA.SCOMAdmin.WindowsDiscoveryDataSourceModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="IgnoreAgentMgmtGroups" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="IgnoreGatewayMgmtGroups" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
<OverrideableParameter ID="IgnoreAgentMgmtGroups" Selector="$Config/IgnoreAgentMgmtGroups$" ParameterType="string" />
<OverrideableParameter ID="IgnoreGatewayMgmtGroups" Selector="$Config/IgnoreGatewayMgmtGroups$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider">
<IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
<SyncTime>$Config/SyncTime$</SyncTime>
<ScriptName>DXC.PPA.SCOMAdmin.WindowsInventory.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start Windows discovery
Param ($SourceId,$ManagedEntityId,$ComputerName,$IgnoreAgentMgmtGroups,$IgnoreGatewayMgmtGroups) # Need this line to pass params in properly.

<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17611
$EventLevel=2
}
Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17610
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("DXC.PPA.SCOMAdmin.WindowsInventory.ps1", $EventId, $EventLevel, "Windows inventory discovery script executed.`nWorkflow Name: DXC.PPA.SCOMAdmin.WindowsPowerShellDiscovery`nManagement Pack: DXC.PPA.SCOMAdmin.Monitoring (1.0.0.51)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}

<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
If ($ValueToCheck -eq "LAProxyUrl") { # This If statement allows us to do custom things when an empty value is not considered an error.
$Script:LAProxyUrl="n/a"
}
ElseIf ($ValueToCheck -eq "LAProxyUsername") {
$Script:LAProxyUsername="n/a"
}
Else {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
}
}
Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}
}

<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}

<#**************************************** FUNCTION: GetServiceInfo ****************************************#>
Function GetServiceInfo ($PassedInParam) {
$Script:ServiceAccount=$null; $Script:ServiceStartMode=$null # Reset these.
$Script:ServiceAccount=(Get-ItemProperty $PassedInParam).ObjectName
$ValueToCheck="ServiceAccount"; CheckNull $ServiceAccount # Expect value.
$Script:ServiceStartMode=(Get-ItemProperty $PassedInParam).Start
$ValueToCheck="ServiceStartMode"; CheckNull $Script:ServiceStartMode # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch ($Script:ServiceStartMode) {
"2" {$Script:ServiceStartMode="Automatic"; BREAK}
"3" {$Script:ServiceStartMode="Manual"; BREAK}
"4" {$Script:ServiceStartMode="Disabled"; BREAK}
}
}
}

<#**************************************** FUNCTION: CheckFile ****************************************#>
<#
If you add "NoAlert" as second parameter it won't generate alert.
#>
Function CheckFile ($Script:PassedInParam, $Script:PassedInParam2) {
If(Test-Path $script:PassedInParam) {
$Script:FileExists=$True # Update this so we can make decisions.
$script:GetFile=Get-Item $script:PassedInParam
$script:FileLastAccessTimeRaw=$script:GetFile.LastAccessTime
$script:FileLastAccessTime=$script:GetFile.LastAccessTime.ToString("yyyy/MM/dd HH:mm:ss")
$script:FileVersion=$script:GetFile.VersionInfo.FileVersion
}
Else {
$Script:FileExists=$False # Update this so we can make decisions.
If (-Not($Script:PassedInParam2 -eq "NoAlert")) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] File not found: $PassedInParam.`n"
}}}

<#**************************************** FUNCTION: GetWindowsInventory ****************************************#>
Function GetWindowsInventory {
$ErrorActionPreference="Continue"
Try {
<# FOR TESTING
$SourceId='{00000000-0000-0000-0000-000000000000}'
$ManagedEntityId='{00000000-0000-0000-0000-000000000000}'
$ComputerName='agent.scomtest.local'
$IgnoreAgentMgmtGroups="" # Leave blank until you specifically want to test it.
$IgnoreGatewayMgmtGroups="" # Leave blank until you specifically want to test it.
#>

<# CODE_SECTION_1
Load required objects.
#>
$CodeSection="1"
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$DiscoveryData=$ObjMomApi.CreateDiscoveryData(0, $SourceId, $ManagedEntityId) # Create MOMDiscoveryData object to store discovery data.
$ObjAgentConfig=New-Object -ComObject "AgentConfigManager.MgmtSvcCfg" # Agent config API object.

<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor

<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.
$WinDir=(Get-ChildItem Env:windir).Value
$ValueToCheck="WinDir"; CheckNull $WinDir # Expect value.

<# CODE_SECTION_4
Get operating system.
#>
$CodeSection="4"
$OperatingSystem=(Get-CimInstance -ClassName Win32_OperatingSystem).Caption
$ValueToCheck="OperatingSystem"; CheckNull $OperatingSystem # Expect value.

<# CODE_SECTION_5
Determine SCOM role of the computer.
#>
$CodeSection="5"
$SetupRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup"
$Product=(Get-ItemProperty $SetupRegKey).Product # No null check. Script execution means it's present.

<#**************************************** AGENT SECTION ****************************************#>

<# CODE_SECTION_6
Get agent install directory.
#>
$CodeSection="6"
If((Get-ItemProperty $SetupRegKey).AgentVersion) { # No null check. Script execution means it's present.
$AgentInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\") # No null check. Script execution means it's present.

<# CODE_SECTION_7
Get agent UR info.
#>
$CodeSection="7"
$AgentURFile="$AgentInstallDirectory\Tools\TMF\OMAgentTraceTMFVer.Dll" # Best file for UR info.
CheckFile $AgentURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$AgentURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="AgentURInstallDate"; CheckNull $AgentURInstallDate # Expect value.
$AgentVersion=$Script:FileVersion
$ValueToCheck="AgentVersion"; CheckNull $AgentVersion # Expect value.
If ($Script:IsItNull -ne $True) {
Switch($AgentVersion) {
# SCOM 2012 R2
"7.1.10184.0" {$AgentVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10195.0" {$AgentVersion="Update required - 2012 R2 UR2"; BREAK}
"7.1.10204.0" {$AgentVersion="Update required - 2012 R2 UR3"; BREAK}
"7.1.10211.0" {$AgentVersion="Update required - 2012 R2 UR4"; BREAK}
"7.1.10213.0" {$AgentVersion="2Update required - 012 R2 UR5"; BREAK}
"7.1.10218.0" {$AgentVersion="Update required - 2012 R2 UR6"; BREAK}
"7.1.10229.0" {$AgentVersion="Update required - 2012 R2 UR7"; BREAK}
"7.1.10241.0" {$AgentVersion="Update required - 2012 R2 UR8"; BREAK}
"7.1.10268.0" {$AgentVersion="Update required - 2012 R2 UR9"; BREAK}
"7.1.10285.0" {$AgentVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10292.0" {$AgentVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10302.0" {$AgentVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10305.0" {$AgentVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"8.0.10918.0" {$AgentVersion="Update required - 2016 RTM"; BREAK}
"8.0.10931.0" {$AgentVersion="Update required - 2016 UR1"; BREAK}
"8.0.10949.0" {$AgentVersion="Update required - 2016 UR2"; BREAK}
"8.0.10970.0" {$AgentVersion="Update required - 2016 UR3"; BREAK}
"8.0.10977.0" {$AgentVersion="Update required - 2016 UR4"; BREAK}
"8.0.10990.0" {$AgentVersion="Update required - 2016 UR5"; BREAK}
"8.0.11004.0" {$AgentVersion="Update required - 2016 UR6"; BREAK}
"8.0.11025.0" {$AgentVersion="Update required - 2016 UR7"; BREAK}
"8.0.11037.0" {$AgentVersion="Update required - 2016 UR8"; BREAK}
"8.0.11049.0" {$AgentVersion="2016 UR9"; BREAK}
# SCOM 1801
"8.0.13053.0" {$AgentVersion="Update required - 1801"; BREAK}
"8.0.13067.0" {$AgentVersion="1807"; BREAK}
# SCOM 2019
"10.19.10014.0" {$AgentVersion="Update required - 2019 RTM"; BREAK}
"10.19.10140.0" {$AgentVersion="Update required - 2019 UR1"; BREAK}
"10.19.10153.0" {$AgentVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown agent version: $AgentVersion.`n"; # Catch unknown versions.
$AgentVersion="Unknown version - $AgentVersion"
}}}}

<# CODE_SECTION_8
Get agent management groups.
#>
$CodeSection="8"
$IgnoreAgentMgmtGroups=$IgnoreAgentMgmtGroups.Split(",") # Split into array so we can check each item.
$AgentMGFolders=Get-ChildItem -Directory -Path "$AgentInstallDirectory\Health Service State\Connector Configuration Cache" # Get folders only. Script is running so don't check for existence.
$AgentMGCount=($AgentMGFolders | Measure-Object).Count
$AgentMGFolders | ForEach-Object {
$MGName=$_.Name
$AgentConfigFile="$AgentInstallDirectory\Health Service State\Connector Configuration Cache\$MGName\OpsMgrConnector.Config.xml" # Script is running so don't check for existence.
If (Test-Path -Path $AgentConfigFile) {
$XPath="Message/State/Parents/Added/Item" # Set XPath so we can find primary/failover server info.
$GetPrimaryXml=Select-Xml -Path $AgentConfigFile -XPath $XPath | Select-Object -ExpandProperty node | Where-Object {$_.IsPrimary -eq "True"}
$Primary=$GetPrimaryXml.AuthenticationName
$MGOverride=$IgnoreAgentMgmtGroups -contains $MGName
If ($MGOverride -eq $True) { # If overriden loop to next.
$AgentMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=(OverrideIgnore);"
} Else { # Get failovers.
$Failovers=$null # Reset these.
$GetFailoverXml=Select-Xml -Path $AgentConfigFile -XPath $XPath | Select-Object -ExpandProperty node | Where-Object {$_.IsPrimary -eq "False"} | Sort-Object AuthenticationName # array of failovers.
If (($GetFailoverXml | Measure-Object).Count -gt 0) { # If more than one failovers update $Failovers array.
$GetFailoverXml | ForEach-Object {
$Failovers+=$_.AuthenticationName + ","
}
$Failovers=$Failovers.TrimEnd(",")
$AgentMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=$Failovers;" # Update $AgentMGFailovers array.
} Else { # If no failovers AND no override then generate warning.
$AgentMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=;" # Update $AgentMGFailovers array.
$Script:Message+="[CODE_SECTION_$CodeSection] Agent in management group $MGName has no failover servers configured.`n"
$Script:CountError+=1
}
}
} Else {
$Script:Message+="[CODE_SECTION_$CodeSection] Agent in management group $MGName has no OpsMgrConnector.Config.xml file.`n"
$AgentMGFailovers+="MGName=$MGName,MissingConfigFile;" # Update $AgentMGFailovers array.
$Script:CountError+=1
}
}
$AgentMGFailovers=$AgentMGFailovers.TrimEnd(";")
} Else {
$AgentInstallDirectory="n/a"
$AgentURInstallDate="n/a"
$AgentVersion="n/a"
$AgentMGFailovers="n/a"
$AgentMGCount="n/a"
}

<#**************************************** COMMON SECTION ****************************************#>

<# CODE_SECTION_9
Get HealthService account and start mode.
#>
$CodeSection="9"
$HealthServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService"
GetServiceInfo $HealthServiceRegKey
$Script:HealthServiceAccount=$Script:ServiceAccount
$Script:HealthServiceStartMode=$Script:ServiceStartMode

<# CODE_SECTION_10
Get certificate.
#>
$CodeSection="10"
$CertRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Machine Settings"
If ((Get-ItemProperty $CertRegKey).ChannelCertificateHash) {
$Hash=(Get-ItemProperty $CertRegKey).ChannelCertificateHash
$Thumbprint=Get-ChildItem -Path cert:\LocalMachine\My | Where-Object {$_.Thumbprint -eq $Hash}
$CertificateExpiryDate=$Thumbprint.NotAfter.ToString("yyyy/MM/dd HH:mm:ss")
$ValueToCheck="CertificateExpiryDate"; CheckNull $CertificateExpiryDate # Expect value.
}
Else {
$CertificateExpiryDate="n/a"
}

<# CODE_SECTION_11
Get AD Integration setting.
#>
$CodeSection="11"
$ADIntegRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\ConnectorManager"
$ADIntegration=(Get-ItemProperty $ADIntegRegKey).EnableADIntegration
$ValueToCheck="ADIntegration"; CheckNull $ADIntegration # Expect value.
If ($Script:IsItNull -ne $True) {
Switch ($ADIntegration) {
"0" {$ADIntegration="Disabled"; BREAK}
"1" {$ADIntegration="Enabled"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown AD Integration value: $ADIntegration`n";
$Script:CountError+=1
}
}}

<# CODE_SECTION_12
Get APM service StartMode type.
This may not be installed so don't alert if not found.
#>
$CodeSection="12"
$APMServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\System Center Management APM"
If (Test-Path $APMServiceRegKey) {
$APMInstalled="Yes"
GetServiceInfo $APMServiceRegKey
$Script:APMServiceAccount=$Script:ServiceAccount
$Script:APMServiceStartMode=$Script:ServiceStartMode
}
Else {
$APMInstalled="No"
$APMServiceAccount="n/a"
$APMServiceStartMode="n/a"
}

<# CODE_SECTION_13
Get ACS forwarder.
This should be installed on all ms, gw, agent. Alert if not found.
#>
$CodeSection="13"
$ACSForwarderServiceRegKey="HKLM:SYSTEM\CurrentControlSet\Services\AdtAgent"
GetServiceInfo $ACSForwarderServiceRegKey
$Script:ACSForwarderServiceAccount=$Script:ServiceAccount
$Script:ACSForwarderServiceStartMode=$Script:ServiceStartMode

<# CODE_SECTION_14
Get TLS1.2 registry settings.
This checks if the server has been explicitly configured to communicate with only TLS1.2 (i.e. all other protocols disabled).
#>
$CodeSection="14"
$Count=0
$ArrayTLS12NETEnabled="HKLM:\SOFTWARE\Microsoft\.NETFramework\v4.0.30319","HKLM:\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319"
$ArrayTLS12NETEnabled | ForEach-Object {
If (Test-Path -Path $_) {
$TLS12NETEnabled=(Get-ItemProperty $_).SchUseStrongCrypto
If ($TLS12NETEnabled -eq 1) {
$Count+=1
}
}
}
$TLS12OSRegKey="HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2"
$ArrayTLS12OS="Client","Server"
$ArrayTLS12OS | ForEach-Object {
If (Test-Path -Path "$TLS12OSRegKey\$_") {
$TLS12OSEnabled=(Get-ItemProperty "$TLS12OSRegKey\$_").Enabled
$TLS12OSDisabledByDefault=(Get-ItemProperty "$TLS12OSRegKey\$_").DisabledByDefault
If ($TLS12OSEnabled -eq 1 -and $TLS12OSDisabledByDefault -eq 0) {
$Count+=1
}
}
}
If ($Count -eq 0) {
$TLS12="NoConfig"
}
ElseIf ($Count -eq 4) {
$TLS12="CorrectConfig"
}
Else {
$TLS12="IncompleteConfig"
}

<# CODE_SECTION_15
Get Log Analytics workspaces.
Using the AgentConfigManager.MgmtSvcCfg object isn't reliable for collecting LA workspace info so we use the registry instead.
#>
$CodeSection="15"
$LAWorkspaceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\Service Connector Services"
If (Test-Path $LAWorkspaceRegKey) {
$BindLAWorkspaceRegKey=Get-Item $LAWorkspaceRegKey # Bind to the reg key so we can get properties.
$LAWorkspaceCount=($BindLAWorkspaceRegKey).SubKeyCount # This is the $LAWorkspaceCount property.
If ($LAWorkspaceCount -gt 0) { # If 0 workspaces set $LAWorkspaces to "None" otherwise do below...
$ArrayLAWorkspaces=$BindLAWorkspaceRegKey.GetSubKeyNames() # Get each subkey and create an array in case there's more than 1.
$ArrayLAWorkspaces | ForEach-Object { # Cycle through each item in the array.
$LAWorkspaceId=$_.Substring(16) # Remove "Log Analytics - " from the key name so we just have the workspace id.
$LAWorkspaceType=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Azure Cloud Type"
$ValueToCheck="LAWorkspaceType"; CheckNull $LAWorkspaceType
If ($Script:IsItNull -ne $True) { # 
Switch ($LAWorkspaceType) {
"0" {$LAWorkspaceType="Azure Commercial"; BREAK}
"1" {$LAWorkspaceType="Azure US Government"; BREAK}
"2" {$LAWorkspaceType="Azure China"; BREAK}
"3" {$LAWorkspaceType="Azure US Nat"; BREAK}
"4" {$LAWorkspaceType="Azure US Sec"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown log analytics workspace type: $LAWorkspaceType`n";
$Script:CountError+=1
}
}
}
$LAWorkspaces+="Type=$LAWorkspaceType,WorkSpaceId=$LAWorkspaceId;"
}
$LAWorkspaces=$LAWorkspaces.TrimEnd(";")
}
Else {
$LAWorkspaceCount="0"
$LAWorkspaces="n/a"
}
}
Else {
$LAWorkspaceCount="0"
$LAWorkspaces="n/a"
}

<# CODE_SECTION_16
Get Log Analytics proxy server used to connect to Log Analytics.
If this is empty it's not an error but we need to add custom discovery data so need a null check. There is a reference in the CheckNull function for this. It's not pretty but it let's us reuse code.
#>
$CodeSection="16"
$Script:LAProxyUrl=$ObjAgentConfig.proxyUrl
$ValueToCheck="LAProxyUrl"; CheckNull $Script:LAProxyUrl # Add custom discovery data

<# CODE_SECTION_17
Get Log Analytics account used to authenticate to the proxy server.
If this is empty it's not an error but we need to add custom discovery data so need a null check. There is a reference in the CheckNull function for this. It's not pretty but it let's us reuse code.
#>
$CodeSection="17"
$Script:LAProxyUsername=$ObjAgentConfig.proxyUsername
$ValueToCheck="LAProxyUsername"; CheckNull $Script:LAProxyUsername # Expect value.

<# CODE_SECTION_18
Get computer type.
#>
$CodeSection="18"
$ComputerType=(Get-CimInstance -ClassName Win32_ComputerSystem).Model
$ValueToCheck="ComputerType"; CheckNull $ComputerType # Expect value.

<#**************************************** MGMT SERVER SECTION ****************************************#>

If((Get-ItemProperty $SetupRegKey).ServerVersion) {

<# CODE_SECTION_19
Get mgmt server install directory.
#>
$CodeSection="19"
$MgmtServerInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="MgmtServerInstallDirectory"; CheckNull $MgmtServerInstallDirectory # Expect value.

<# CODE_SECTION_20
Get management server UR info.
#>
$CodeSection="20"
$MgmtServerURFile="$MgmtServerInstallDirectory\Tools\TMF\OMTraceTMFVer.Dll" # Best file for UR info.
CheckFile $MgmtServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$MgmtServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="MgmtServerURInstallDate"; CheckNull $MgmtServerURInstallDate # Expect value.
$MgmtServerVersion=$Script:FileVersion
$ValueToCheck="MgmtServerVersion"; CheckNull $MgmtServerVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($MgmtServerVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$MgmtServerVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$MgmtServerVersion="Update required - 2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$MgmtServerVersion="Update required - 2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$MgmtServerVersion="Update required - 2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$MgmtServerVersion="Update required - 2012 R2 UR4"; BREAK}
"7.1.10226.1052" {$MgmtServerVersion="Update required - 2012 R2 UR5"; BREAK}
"7.1.10226.1064" {$MgmtServerVersion="Update required - 2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$MgmtServerVersion="Update required - 2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$MgmtServerVersion="Update required - 2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$MgmtServerVersion="Update required - 2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$MgmtServerVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$MgmtServerVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$MgmtServerVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$MgmtServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$MgmtServerVersion="Update required - 2016 RTM"; BREAK}
"7.2.11759.0" {$MgmtServerVersion="Update required - 2016 UR1"; BREAK}
"7.2.11822.0" {$MgmtServerVersion="Update required - 2016 UR2"; BREAK}
"7.2.11878.0" {$MgmtServerVersion="Update required - 2016 UR3"; BREAK}
"7.2.11938.0" {$MgmtServerVersion="Update required - 2016 UR4"; BREAK}
"7.2.12016.0" {$MgmtServerVersion="Update required - 2016 UR5"; BREAK}
"7.2.12066.0" {$MgmtServerVersion="Update required - 2016 UR6"; BREAK}
"7.2.12150.0" {$MgmtServerVersion="Update required - 2016 UR7"; BREAK}
"7.2.12213.0" {$MgmtServerVersion="Update required - 2016 UR8"; BREAK}
"7.2.12265.0" {$MgmtServerVersion="2016 UR9"; BREAK}
# SCOM 1801
"7.3.13142.0" {$MgmtServerVersion="Update required - 1801"; BREAK}
"7.3.13261.0" {$MgmtServerVersion="1807"; BREAK}
# SCOM 2019
"10.19.10050.0" {$MgmtServerVersion="Update required - 2019 RTM"; BREAK}
"10.19.10311.0" {$MgmtServerVersion="Update required - 2019 UR1"; BREAK}
"10.19.10349.0" {$MgmtServerVersion="Update required - 2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$MgmtServerVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown management server version: $MgmtServerVersion.`n"; # Catch unknown versions.
$MgmtServerVersion="Unknown version - $MgmtServerVersion"
}}}}

<# CODE_SECTION_21
Get CSHostService account and start mode.
#>
$CodeSection="21"
$ConfigServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\cshost"
GetServiceInfo $ConfigServiceRegKey
$Script:ConfigServiceAccount=$Script:ServiceAccount
$Script:ConfigServiceStartMode=$Script:ServiceStartMode

<# CODE_SECTION_22
Get OMSDKService account and start mode.
#>
$CodeSection="22"
$DataAccessServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\OMSDK"
GetServiceInfo $DataAccessServiceRegKey
$Script:DataAccessServiceAccount=$Script:ServiceAccount
$Script:DataAccessServiceStartMode=$Script:ServiceStartMode

<# CODE_SECTION_23
Get ops db name.
#>
$CodeSection="23"
$OpsDbName=(Get-ItemProperty $SetupRegKey).DatabaseName
$ValueToCheck="OpsDbName"; CheckNull $OpsDbName # Expect value.

<# CODE_SECTION_24
Get ops db server name.
#>
$CodeSection="24"
$OpsDbServer=(Get-ItemProperty $SetupRegKey).DatabaseServerName
$ValueToCheck="OpsDbServer"; CheckNull $OpsDbServer # Expect value.

<# CODE_SECTION_25
Get data warehouse db name.
#>
$CodeSection="25"
$DWDbName=(Get-ItemProperty $SetupRegKey).DataWarehouseDBName
$ValueToCheck="DWDbName"; CheckNull $DWDbName # Expect value.

<# CODE_SECTION_26
Get data warehouse db server name.
#>
$CodeSection="26"
$DwDbServer=(Get-ItemProperty $SetupRegKey).DataWarehouseDBServerName
$ValueToCheck="DwDbServer"; CheckNull $DwDbServer # Expect value.

<# CODE_SECTION_27
# Get service info.
#>
$CodeSection="27"
$ACSCollectorServiceRegKey="HKLM:SYSTEM\CurrentControlSet\Services\AdtServer" # If this key exists it's an ACS collector.
If (Test-Path $ACSCollectorServiceRegKey) {
$ACSCollector="Yes"
GetServiceInfo $ACSCollectorServiceRegKey
$Script:ACSCollectorServiceAccount=$Script:ServiceAccount
$Script:ACSCollectorServiceStartMode=$Script:ServiceStartMode

<# CODE_SECTION_28
Get ACS collector UR info.
#>
$CodeSection="28"
$ACSCollectorURFile="$WinDir\System32\Security\AdtServer\OmacAdmn.dll" # Best file for UR info.
CheckFile $ACSCollectorURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$ACSCollectorURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="ACSCollectorURInstallDate"; CheckNull $ACSCollectorURInstallDate # Expect value.
$ACSCollectorVersion=$Script:FileVersion
$ValueToCheck="ACSCollectorVersion"; CheckNull $ACSCollectorVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ACSCollectorVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$ACSCollectorVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10226.1239" {$ACSCollectorVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$ACSCollectorVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ACSCollectorVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ACSCollectorVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ACSCollectorVersion="Update required - 2016 RTM"; BREAK}		
"7.2.11938.0" {$ACSCollectorVersion="Update required - 2016 UR4"; BREAK}		
"7.2.12016.0" {$ACSCollectorVersion="Update required - 2016 UR5"; BREAK}
"7.2.12066.0" {$ACSCollectorVersion="Update required - 2016 UR6"; BREAK}
"7.2.12150.0" {$ACSCollectorVersion="Update required - 2016 UR7"; BREAK}
"7.2.12213.0" {$ACSCollectorVersion="Update required - 2016 UR8"; BREAK}		
"7.2.12265.0" {$ACSCollectorVersion="2016 UR9"; BREAK}		
# SCOM 1801
"7.3.13142.0" {$ACSCollectorVersion="Update required - 1801"; BREAK}		
"7.3.13261.0" {$ACSCollectorVersion="1807"; BREAK}	
# SCOM 2019
"10.19.10050.0" {$ACSCollectorVersion="Update required - 2019 RTM"; BREAK}
"10.19.10140.0" {$ACSCollectorVersion="2019 UR1"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown ACS collector version: $ACSCollectorVersion.`n"; # Catch unknown versions.
$ACSCollectorVersion="Unknown version - $ACSCollectorVersion"
}}}}}
Else {
$ACSCollector="No"
$ACSCollectorServiceAccount="n/a"
$ACSCollectorServiceStartMode="n/a"
$ACSCollectorURInstallDate="n/a"
$ACSCollectorVersion="n/a"
}

<# CODE_SECTION_29
Get RMS owner.
#>
$CodeSection="29"
$Connection=New-Object System.Data.SQLClient.SQLConnection
$Query="SELECT [PrincipalName] FROM [$OpsDbName].[dbo].[MTV_HealthService] WHERE IsRHS='1'"
$Connection.ConnectionString="Data Source=$OpsDbServer;Database=$OpsDbName;Trusted_Connection=True;"
$Connection.Open()
$Command=New-Object System.Data.SQLClient.SQLCommand
$Command.Connection=$Connection
$Command.CommandText=$Query
$Reader=$Command.ExecuteReader()
$Datatable=New-Object System.Data.DataTable
$Datatable.Load($Reader)
$RMSFqdn=$Datatable.PrincipalName
$Connection.Close() 
If($RMSFqdn -eq $ComputerFqdn) {
$RMS="Yes"
} Else {
$RMS="No"
}

}
Else {
$MgmtServerInstallDirectory="n/a"
$MgmtServerURInstallDate="n/a"
$MgmtServerVersion="n/a"
$ConfigServiceAccount="n/a"
$ConfigServiceStartMode="n/a"
$DataAccessServiceAccount="n/a"
$DataAccessServiceStartMode="n/a"
$OpsDbName="n/a"
$OpsDbServer="n/a"
$DWDbName="n/a"
$DwDbServer="n/a"
$ACSCollector="No"
$ACSCollectorServiceAccount="n/a"
$ACSCollectorServiceStartMode="n/a"
$ACSCollectorURInstallDate="n/a"
$ACSCollectorVersion="n/a"
$RMS="n/a"
}

<#**************************************** GATEWAY SERVER SECTION ****************************************#>

If((Get-ItemProperty $SetupRegKey).MOMGatewayVersion) {#1

<# CODE_SECTION_30
Get gateway server install directory.
#>
$CodeSection="30"
$GatewayServerInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="GatewayServerInstallDirectory"; CheckNull $GatewayServerInstallDirectory # Expect value.

<# CODE_SECTION_31
Get gateway server UR info
There are different files for different versions.
#>
$CodeSection="31"
$GatewayServerURFile="$GatewayServerInstallDirectory\HealthService.dll" # Should be on all versions. Best UR file for 2012 R2 (All URs), 2016 (UR2, UR4-9), 2019 UR1.
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$GatewayServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
If ($GatewayServerVersion -match "8.0.10970.0") {  # Best UR file for 2016 UR3.
$GatewayServerURFile="$GatewayServerInstallDirectory\MomWsManModules.dll"
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True){
$GatewayServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
}
} ElseIf ($GatewayServerVersion -match "8.0.13053.0") {  # Best UR file for 1801.
$GatewayServerURFile="$GatewayServerInstallDirectory\MOMAgentManagement.dll"
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True){
$GatewayServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
}
}
$ValueToCheck="GatewayServerURInstallDate"; CheckNull $GatewayServerURInstallDate # Expect value.
$ValueToCheck="GatewayServerVersion"; CheckNull $GatewayServerVersion # Expect value.

If ($Script:IsItNull -ne $True) {
Switch($GatewayServerVersion) {
# SCOM 2012 R2
"7.1.10184.0" {$GatewayServerVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10188.0" {$GatewayServerVersion="Update required - 2012 R2 UR1"; BREAK}
"7.1.10195.0" {$GatewayServerVersion="Update required - 2012 R2 UR2"; BREAK}
"7.1.10204.0" {$GatewayServerVersion="Update required - 2012 R2 UR3"; BREAK}
"7.1.10211.0" {$GatewayServerVersion="Update required - 2012 R2 UR4"; BREAK}
"7.1.10213.0" {$GatewayServerVersion="Update required - 2012 R2 UR5"; BREAK}
"7.1.10218.0" {$GatewayServerVersion="Update required - 2012 R2 UR6"; BREAK}
"7.1.10229.0" {$GatewayServerVersion="Update required - 2012 R2 UR7"; BREAK}
"7.1.10241.0" {$GatewayServerVersion="Update required - 2012 R2 UR8"; BREAK}
"7.1.10268.0" {$GatewayServerVersion="Update required - 2012 R2 UR9"; BREAK}
"7.1.10285.0" {$GatewayServerVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10292.0" {$GatewayServerVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10302.0" {$GatewayServerVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10305.0" {$GatewayServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"8.0.10918.0" {$GatewayServerVersion="Update required - 2016 RTM"; BREAK}
"8.0.10949.0" {$GatewayServerVersion="Update required - 2016 UR2"; BREAK}
"8.0.10970.0" {$GatewayServerVersion="Update required - 2016 UR3"; BREAK}
"8.0.10977.0" {$GatewayServerVersion="Update required - 2016 UR4"; BREAK}		
"8.0.10990.0" {$GatewayServerVersion="Update required - 2016 UR5"; BREAK}
"8.0.11004.0" {$GatewayServerVersion="Update required - 2016 UR6"; BREAK}
"8.0.11025.0" {$GatewayServerVersion="Update required - 2016 UR7"; BREAK}
"8.0.11037.0" {$GatewayServerVersion="Update required - 2016 UR8"; BREAK}		
"8.0.11049.0" {$GatewayServerVersion="2016 UR9"; BREAK}		
# SCOM 1801
"8.0.13053.0" {$GatewayServerVersion="Update required - 1801"; BREAK}		
"7.3.13261.0" {$GatewayServerVersion="1807"; BREAK} # yes this is the correct version even though the number is older.
# SCOM 2019
"10.19.10014.0" {$GatewayServerVersion="Update required - 2019 RTM"; BREAK}
"10.19.10140.0" {$GatewayServerVersion="Update required - 2019 UR1"; BREAK}
"10.19.10153.0" {$GatewayServerVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown gateway server version: $GatewayServerVersion.`n";
$GatewayServerVersion="Unknown version - $GatewayServerVersion"
}}}}

<# CODE_SECTION_32
Get gateway management groups.
#>
$CodeSection="32"
$IgnoreGatewayMgmtGroups=$IgnoreGatewayMgmtGroups.Split(",") # Split into array so we can check each item.
$GatewayMGFolders=Get-ChildItem -Directory -Path "$GatewayServerInstallDirectory\Health Service State\Connector Configuration Cache" # Get folders only.
$GatewayMGCount=($GatewayMGFolders | Measure-Object).Count
$GatewayMGFolders | ForEach-Object {
$MGName=$_.Name
$GatewayConfigFile="$GatewayServerInstallDirectory\Health Service State\Connector Configuration Cache\$MGName\OpsMgrConnector.Config.xml"
If (Test-Path -Path $GatewayConfigFile) {
$XPath="Message/State/Parents/Added/Item" # Set XPath so we can find primary/failover server info.
$GetPrimaryXml=Select-Xml -Path $GatewayConfigFile -XPath $XPath | Select-Object -ExpandProperty node | Where-Object {$_.IsPrimary -eq "True"}
$Primary=$GetPrimaryXml.AuthenticationName
$MGOverride=$IgnoreGatewayMgmtGroups -contains $MGName
If ($MGOverride -eq $True) { # If overriden loop to next.
$GatewayMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=(OverrideIgnore);"
} Else { # Get failovers.
$Failovers=$null # Reset these.
$GetFailoverXml=Select-Xml -Path $GatewayConfigFile -XPath $XPath | Select-Object -ExpandProperty node | Where-Object {$_.IsPrimary -eq "False"} | Sort-Object AuthenticationName # array of failovers.
If (($GetFailoverXml | Measure-Object).Count -gt 0) { # If more than one failovers update $Failovers array.
$GetFailoverXml | ForEach-Object {
$Failovers+=$_.AuthenticationName + ","
}
$Failovers=$Failovers.TrimEnd(",")
$GatewayMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=$Failovers;" # Update $GatewayMGFailovers array.
} Else { # If no failovers AND no override then generate warning.
$GatewayMGFailovers+="MGName=" + $MGName + ",Primary=$Primary,Failovers=;" # Update $GatewayMGFailovers array.
$Script:Message+="[CODE_SECTION_$CodeSection] Gateway server in management group $MGName has no failover servers configured.`n"
$Script:CountError+=1
}
}
} Else {
$Script:Message+="[CODE_SECTION_$CodeSection] Gateway server in management group $MGName has no OpsMgrConnector.Config.xml file.`n"
$GatewayMGFailovers+="MGName=$MGName,MissingConfigFile;" # Update $GatewayMGFailovers array.
$Script:CountError+=1
}
}
$GatewayMGFailovers=$GatewayMGFailovers.TrimEnd(";")
} Else {#1
$GatewayServerInstallDirectory="n/a"
$GatewayServerURInstallDate="n/a"
$GatewayServerVersion="n/a"
$GatewayMGCount="n/a"
$GatewayMGFailovers="n/a"
}

<#**************************************** WEB CONSOLE SERVER SECTION ****************************************#>

$WebConsoleRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\WebConsole"
If(Test-Path $WebConsoleRegKey) {
<# CODE_SECTION_33
Get web console install directory.
#>
$CodeSection="33"
$WebConsoleInstallDirectory=(Get-ItemProperty $WebConsoleRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="WebConsoleInstallDirectory"; CheckNull $WebConsoleInstallDirectory # Expect value.

<# CODE_SECTION_34
Get web console UR file info.
There are different files for different versions.
#>
$CodeSection="34"
$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.EnterpriseManagement.Management.DataProviders.dll" # Best UR file for 2012 R2.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.1.1") {
$WebConsoleURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}

$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.EnterpriseManagement.Monitoring.DataProviders.dll" # Best UR file for 2016.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.2.1") {
$WebConsoleURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}

$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.Mom.Common.dll" # Best UR file for 1801.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.3.1") {
$WebConsoleURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}

$WebConsoleURFile="$WebConsoleInstallDirectory\Dashboard\bin\Microsoft.EnterpriseManagement.OMDataService.dll" # Best UR file for 2019.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "10.19") {
$WebConsoleURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}
$ValueToCheck="WebConsoleURInstallDate"; CheckNull $WebConsoleURInstallDate # Expect value.
$ValueToCheck="WebConsoleVersion"; CheckNull $WebConsoleVersion # Expect value.
If ($Script:IsItNull -ne $True) {
Switch($WebConsoleVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$WebConsoleVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$WebConsoleVersion="Update required - 2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$WebConsoleVersion="Update required - 2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$WebConsoleVersion="Update required - 2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$WebConsoleVersion="Update required - 2012 R2 UR4"; BREAK}
"7.1.10226.1052" {$WebConsoleVersion="Update required - 2012 R2 UR5"; BREAK}
"7.1.10226.1064" {$WebConsoleVersion="Update required - 2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$WebConsoleVersion="Update required - 2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$WebConsoleVersion="Update required - 2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$WebConsoleVersion="Update required - 2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$WebConsoleVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$WebConsoleVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$WebConsoleVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$WebConsoleVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$WebConsoleVersion="Update required - 2016 RTM"; BREAK}
"7.2.11759.0" {$WebConsoleVersion="Update required - 2016 UR1"; BREAK}
"7.2.11822.0" {$WebConsoleVersion="Update required - 2016 UR2"; BREAK}
"7.2.11878.0" {$WebConsoleVersion="Update required - 2016 UR3"; BREAK}
"7.2.11938.0" {$WebConsoleVersion="Update required - 2016 UR4"; BREAK}		
"7.2.12016.0" {$WebConsoleVersion="Update required - 2016 UR5"; BREAK}
"7.2.12066.0" {$WebConsoleVersion="Update required - 2016 UR6"; BREAK}
"7.2.12150.0" {$WebConsoleVersion="Update required - 2016 UR7"; BREAK}
"7.2.12213.0" {$WebConsoleVersion="Update required - 2016 UR8"; BREAK}		
"7.2.12265.0" {$WebConsoleVersion="2016 UR9"; BREAK}		
# SCOM 1801
"7.3.13142.0" {$WebConsoleVersion="Update required - 1801"; BREAK}		
"7.3.13261.0" {$WebConsoleVersion="7.3.13261.0 (1807"; BREAK} # this is how we id the 1807 patch on a web server.
# SCOM 2019
"10.19.10050.0" {$WebConsoleVersion="Update required - 2019 RTM"; BREAK}
"10.19.10311.0" {$WebConsoleVersion="Update required - 2019 UR1"; BREAK}
"10.19.10349.0" {$WebConsoleVersion="Update required - 2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$WebConsoleVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown web console version: $WebConsoleVersion.`n"; # Check #4. If previous 3 checks fail it must be a new version of the WebConsole. Generate warning so we know to update mp.
$WebConsoleVersion="Unknown version - $WebConsoleVersion"
}}}

<# CODE_SECTION_35
Get Authentication Mode.
#>
$CodeSection="35"
$AuthenticationMode=(Get-ItemProperty $WebConsoleRegKey).AUTHENTICATION_MODE
$ValueToCheck="AuthenticationMode"; CheckNull $AuthenticationMode # Expect value.

<# CODE_SECTION_36
Get DefaultServer.
#>
$CodeSection="36"
$DefaultServer=(Get-ItemProperty $WebConsoleRegKey).DEFAULT_SERVER
$ValueToCheck="DefaultServer"; CheckNull $DefaultServer # Expect value.

<# CODE_SECTION_37
Get WebConsoleUrl.
#>
$CodeSection="37"
$WebConsoleUrl=(Get-ItemProperty $WebConsoleRegKey).WEB_CONSOLE_URL
$ValueToCheck="WebConsoleUrl"; CheckNull $WebConsoleUrl # Expect value.

<# CODE_SECTION_38
Get ApmAdvisorUrl.
#>
$CodeSection="38"
$ApmAdvisorUrl=(Get-ItemProperty $WebConsoleRegKey).APM_ADVISOR_URL
$ValueToCheck="ApmAdvisorUrl"; CheckNull $ApmAdvisorUrl # Expect value.

<# CODE_SECTION_39
Get ApmDiagnosticsUrl.
#>
$CodeSection="39"
$ApmDiagnosticsUrl=(Get-ItemProperty $WebConsoleRegKey).APM_DIAGNOSTICS_URL
$ValueToCheck="ApmDiagnosticsUrl"; CheckNull $ApmDiagnosticsUrl # Expect value.

}
Else {
$WebConsoleInstallDirectory="n/a"
$WebConsoleURInstallDate="n/a"
$WebConsoleVersion="n/a"
$AuthenticationMode="n/a"
$DefaultServer="n/a"
$WebConsoleUrl="n/a"
$ApmAdvisorUrl="n/a"
$ApmDiagnosticsUrl="n/a"
}

<#**************************************** REPORT SERVER SECTION ****************************************#>

<# CODE_SECTION_40
Get report server install directory.
#>
$ReportServerRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Reporting" # If this key exists it's a SCOM report server.
If(Test-Path $ReportServerRegKey) {
$CodeSection="40"
$ReportServerInstallDirectory=(Get-ItemProperty $ReportServerRegKey\..\Setup\Reporting).InstallDirectory.TrimEnd("\")
$ValueToCheck="ReportServerInstallDirectory"; CheckNull $ReportServerInstallDirectory # Expect value.

<# CODE_SECTION_41
Get report server UR info.
There are different files for different versions. 
#>
$CodeSection="41"
$ReportServerURFile="$ReportServerInstallDirectory\Microsoft.Mom.Common.dll" # Get SCOM version. Every RS has this file. Best file for 2012 R2 with no URs installed.
CheckFile $ReportServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) { # Check file versions to determine the right one to use.
If($Script:FileVersion -match "7.1.1") { # 2012 R2.
$ReportServerURFile="$ReportServerInstallDirectory\SDK Binaries\Microsoft.EnterpriseManagement.OperationsManager.dll" # If a 2012 R2 UR has been installed this file will exist.
CheckFile $ReportServerURFile NoAlert # Don't alert if file doesn't exist.
$ReportServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}
ElseIf (($Script:FileVersion -match "7.2.1") -or ($Script:FileVersion -match "7.3.1" )) {# 2016, 1801.
$ReportServerURFile="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.OperationsManager\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.OperationsManager.dll"
CheckFile $ReportServerURFile # Alert if file doesn't exist.
$ReportServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}
ElseIf ($Script:FileVersion -match "10.19") { # 2019.
$File1="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.Core\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.Core.dll" # RTM & UR1Hotfix. Created when RS installed.
CheckFile $File1 # Alert if file doesn't exist.
$ReportServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
$File1Date=$Script:FileLastAccessTimeRaw
$File1Version=$Script:FileVersion
$File2="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.OperationsManager\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.OperationsManager.dll" # UR1, UR2.
CheckFile $File2 NoAlert # Don't alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$File2Date=$Script:FileLastAccessTimeRaw
$File2Version=$Script:FileVersion
If ($File1Date -lt $File2Date) { # If $File2Date is older than $File1Date it means UR1Hotfix has been installed.
$ReportServerURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}}}
$ValueToCheck="ReportServerURInstallDate"; CheckNull $ReportServerURInstallDate # Expect value.
$ValueToCheck="ReportServerVersion"; CheckNull $ReportServerVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ReportServerVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$ReportServerVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10226.1304" {$ReportServerVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ReportServerVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ReportServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ReportServerVersion="Update required - 2016 RTM"; BREAK}
"7.2.12016.0" {$ReportServerVersion="Update required - 2016 UR5"; BREAK}
"7.2.12066.0" {$ReportServerVersion="Update required - 2016 UR6"; BREAK}
"7.2.12150.0" {$ReportServerVersion="Update required - 2016 UR7"; BREAK}
"7.2.12213.0" {$ReportServerVersion="Update required - 2016 UR8"; BREAK}		
"7.2.12265.0" {$ReportServerVersion="2016 UR9"; BREAK}		
# SCOM 1801
"7.3.13142.0" {$ReportServerVersion="Update required - 1801"; BREAK}		
"7.3.13261.0" {$ReportServerVersion="1807"; BREAK}	
# SCOM 2019
"10.19.1032.0" {$ReportServerVersion="Update required - 2019 RTM"; BREAK}
"10.19.10311.0" {$ReportServerVersion="Update required - 2019 UR1"; BREAK}
"10.19.1035.82" {$ReportServerVersion="Update required - 2019 UR1 Hotfix"; BREAK}
"10.19.1035.100" {$ReportServerVersion="2019 UR2"; BREAK} # Microsoft.EnterpriseManagement.Core.dll. Adding 2 values for UR2 in case date compare gets weird.
"10.19.10407.0" {$ReportServerVersion="2019 UR2"; BREAK} # Microsoft.EnterpriseManagement.OperationsManager.dll.
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown report server version: $ReportServerVersion.`n";
$ReportServerVersion="Unknown version - $ReportServerVersion"  
}}}
}

<# CODE_SECTION_42
Get ReportServerDwDbServer.
#>
$CodeSection="42"
$ReportServerDwDbServer=(Get-ItemProperty $ReportServerRegKey).DWDBInstance
$ValueToCheck="ReportServerDwDbServer"; CheckNull $ReportServerDwDbServer # Expect value.

<# CODE_SECTION_43
Get ReportServerDWDBName.
#>
$CodeSection="43"
$ReportServerDWDBName=(Get-ItemProperty $ReportServerRegKey).DWDBName
$ValueToCheck="ReportServerDWDBName"; CheckNull $ReportServerDWDBName # Expect value.

<# CODE_SECTION_44
Get ReportServerUrl.
#>
$CodeSection="44"
$ReportServerUrl=(Get-ItemProperty $ReportServerRegKey).ReportingServerUrl
$ValueToCheck="ReportServerUrl"; CheckNull $ReportServerUrl # Expect value.

<# CODE_SECTION_45
Get SRSInstance.
#>
$CodeSection="45"
$SRSInstance=(Get-ItemProperty $ReportServerRegKey).SRSInstance
$ValueToCheck="SRSInstance"; CheckNull $SRSInstance # Expect value.

<# CODE_SECTION_46
Get report service account and start mode.
Using the registry to get report server service info is unreliable because info returned by different SQL versions and named instances is inconsistent.
#>
$CodeSection="46"
$ReportServerService=Get-CimInstance -ClassName Win32_Service -Filter "DisplayName like 'SQL Server Reporting Services%'" # Confirmed this works on SQL 2012SP4, 2017.
$ReportServerServiceAccount=$ReportServerService.StartName
$ReportServerServiceStartMode=$ReportServerService.StartMode
$ValueToCheck="ReportServerServiceAccount"; CheckNull $ReportServerServiceAccount # Expect value.
$ValueToCheck="ReportServerServiceStartMode"; CheckNull $ReportServerServiceStartMode # Expect value.
}
Else {
$ReportServerInstallDirectory="n/a"
$ReportServerURInstallDate="n/a"
$ReportServerVersion="n/a"
$ReportServerDwDbServer="n/a"
$ReportServerDWDBName="n/a"
$ReportServerUrl="n/a"
$SRSInstance="n/a"
$ReportServerServiceAccount="n/a"
$ReportServerServiceStartMode="n/a"
}

<#**************************************** CONSOLE SECTION ****************************************#>

<# CODE_SECTION_47
Get console directory.
#>
$CodeSection="47"
$ConsoleRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Console" # If this key exists the console is installed.
If(Test-Path $ConsoleRegKey) {
$ConsoleInstallDirectory=(Get-ItemProperty $ConsoleRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="ConsoleInstallDirectory"; CheckNull $ConsoleInstallDirectory # Expect value.

<# CODE_SECTION_48
Get console UR info.
#>
$CodeSection="48"
$ConsoleURFile="$ConsoleInstallDirectory\Tools\TMF\OMTraceTMFVer.Dll" # Best file for UR info.
CheckFile $ConsoleURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$ConsoleURInstallDate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="ConsoleURInstallDate"; CheckNull $ConsoleURInstallDate # Expect value.
$ConsoleVersion=$Script:FileVersion
$ValueToCheck="ConsoleVersion"; CheckNull $ConsoleVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ConsoleVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$ConsoleVersion="Update required - 2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$ConsoleVersion="Update required - 2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$ConsoleVersion="Update required - 2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$ConsoleVersion="Update required - 2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$ConsoleVersion="Update required - 2012 R2 UR4"; BREAK}
"7.1.10226.1064" {$ConsoleVersion="Update required - 2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$ConsoleVersion="Update required - 2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$ConsoleVersion="Update required - 2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$ConsoleVersion="Update required - 2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$ConsoleVersion="Update required - 2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$ConsoleVersion="Update required - 2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ConsoleVersion="Update required - 2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ConsoleVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ConsoleVersion="Update required - 2016 RTM"; BREAK}
"7.2.11759.0" {$ConsoleVersion="Update required - 2016 UR1"; BREAK}
"7.2.11822.0" {$ConsoleVersion="Update required - 2016 UR2"; BREAK}
"7.2.11878.0" {$ConsoleVersion="Update required - 2016 UR3"; BREAK}
"7.2.11938.0" {$ConsoleVersion="Update required - 2016 UR4"; BREAK}		
"7.2.12016.0" {$ConsoleVersion="Update required - 2016 UR5"; BREAK}
"7.2.12066.0" {$ConsoleVersion="Update required - 2016 UR6"; BREAK}
"7.2.12150.0" {$ConsoleVersion="Update required - 2016 UR7"; BREAK}
"7.2.12213.0" {$ConsoleVersion="Update required - 2016 UR8"; BREAK}		
"7.2.12265.0" {$ConsoleVersion="2016 UR9"; BREAK}		
# SCOM 1801
"7.3.13142.0" {$ConsoleVersion="Update required - 1801"; BREAK}		
"7.3.13261.0" {$ConsoleVersion="1807"; BREAK}	
# SCOM 2019
"10.19.10050.0" {$ConsoleVersion="Update required - 2019 RTM"; BREAK}
"10.19.10311.0" {$ConsoleVersion="Update required - 2019 UR1"; BREAK}
"10.19.10349.0" {$ConsoleVersion="Update required - 2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$ConsoleVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown console version: $ConsoleVersion.`n"
$ConsoleVersion="Unknown version - $ConsoleVersion"
}}}}
} Else {
$ConsoleInstallDirectory="n/a"
$ConsoleURInstallDate="n/a"
$ConsoleVersion="n/a"
}

<#**************************************** TESTING SECTION ****************************************#>

<# FOR TESTING
write-host "OperatingSystem: $OperatingSystem"
write-host "Product: $Product"
write-host "AgentInstallDirectory: $AgentInstallDirectory"
write-host "AgentURInstallDate: $AgentURInstallDate"
write-host "AgentVersion: $AgentVersion"
write-host "AgentMGCount: $AgentMGCount"
write-host "AgentMGFailovers: $AgentMGFailovers"
write-host "HealthServiceAccount: $HealthServiceAccount"
write-host "HealthServiceStartMode: $HealthServiceStartMode"
write-host "CertificateExpiryDate: $CertificateExpiryDate"
write-host "ADIntegration: $ADIntegration"
write-host "APMInstalled: $APMInstalled"
write-host "APMServiceAccount: $APMServiceAccount"
write-host "APMServiceStartMode: $APMServiceStartMode"
write-host "ACSForwarderServiceAccount: $ACSForwarderServiceAccount"
write-host "ACSForwarderServiceStartMode: $ACSForwarderServiceStartMode"
write-host "TLS12: $TLS12"
write-host "LAWorkspaceCount: $LAWorkspaceCount"
write-host "LAWorkspaces: $LAWorkspaces"
write-host "LAProxyUrl: $LAProxyUrl"
write-host "LAProxyUsername: $LAProxyUsername"
write-host "ComputerType: $ComputerType"
write-host "MgmtServerInstallDirectory: $MgmtServerInstallDirectory"
write-host "MgmtServerURInstallDate: $MgmtServerURInstallDate"
write-host "MgmtServerVersion: $MgmtServerVersion"
write-host "ConfigServiceAccount: $ConfigServiceAccount"
write-host "ConfigServiceStartMode: $ConfigServiceStartMode"
write-host "DataAccessServiceAccount: $DataAccessServiceAccount"
write-host "DataAccessServiceStartMode: $DataAccessServiceStartMode"
write-host "OpsDbName: $OpsDbName"
write-host "OpsDbServer: $OpsDbServer"
write-host "DWDbName: $DWDbName"
write-host "DwDbServer: $DwDbServer"
write-host "ACSCollector: $ACSCollector"
write-host "ACSCollectorServiceAccount: $ACSCollectorServiceAccount"
write-host "ACSCollectorServiceStartMode: $ACSCollectorServiceStartMode"
write-host "ACSCollectorURInstallDate: $ACSCollectorURInstallDate"
write-host "ACSCollectorVersion: $ACSCollectorVersion"
write-host "RMS: $RMS"
write-host "GatewayServerInstallDirectory: $GatewayServerInstallDirectory"
write-host "GatewayServerURInstallDate: $GatewayServerURInstallDate"
write-host "GatewayServerVersion: $GatewayServerVersion"
write-host "GatewayMGCount: $GatewayMGCount"
write-host "GatewayMGFailovers: $GatewayMGFailovers"
write-host "WebConsoleInstallDirectory: $WebConsoleInstallDirectory"
write-host "WebConsoleURInstallDate: $WebConsoleURInstallDate"
write-host "WebConsoleVersion: $WebConsoleVersion"
write-host "AuthenticationMode: $AuthenticationMode"
write-host "DefaultServer: $DefaultServer"
write-host "WebConsoleUrl: $WebConsoleUrl"
write-host "ApmAdvisorUrl: $ApmAdvisorUrl"
write-host "ApmDiagnosticsUrl: $ApmDiagnosticsUrl"
write-host "ReportServerInstallDirectory: $ReportServerInstallDirectory"
write-host "ReportServerURInstallDate: $ReportServerURInstallDate"
write-host "ReportServerVersion: $ReportServerVersion"
write-host "ReportServerDwDbServer: $ReportServerDwDbServer"
write-host "ReportServerDWDBName: $ReportServerDWDBName"
write-host "ReportServerUrl: $ReportServerUrl"
write-host "SRSInstance: $SRSInstance"
write-host "ReportServerServiceAccount: $ReportServerServiceAccount"
write-host "ReportServerServiceStartMode: $ReportServerServiceStartMode"
write-host "ConsoleInstallDirectory: $ConsoleInstallDirectory"
write-host "ConsoleURInstallDate: $ConsoleURInstallDate"
write-host "ConsoleVersion: $ConsoleVersion"
Write-Host "PSVersion: $PSVersion" # Not returned as discovery data. Only used in events.
Write-Host "IgnoreAgentMgmtGroups: $IgnoreAgentMgmtGroups" # Not returned as discovery data. Only used in events.
Write-Host "IgnoreGatewayMgmtGroups: $IgnoreGatewayMgmtGroups" # Not returned as discovery data. Only used in events.
#>

<#**************************************** ADD DISCOVERY DATA SECTION ****************************************#>

$Instance=$DiscoveryData.CreateClassInstance("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']$")
$Instance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $ComputerName)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/OperatingSystem$", $OperatingSystem)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/Product$", $Product)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AgentInstallDirectory$", $AgentInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AgentURInstallDate$", $AgentURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AgentVersion$", $AgentVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AgentMGCount$", $AgentMGCount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AgentMGFailovers$", $AgentMGFailovers)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/HealthServiceAccount$", $HealthServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/HealthServiceStartMode$", $HealthServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/CertificateExpiryDate$", $CertificateExpiryDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ADIntegration$", $ADIntegration)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/APMInstalled$", $APMInstalled)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/APMServiceAccount$", $APMServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/APMServiceStartMode$", $APMServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSForwarderServiceAccount$", $ACSForwarderServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSForwarderServiceStartMode$", $ACSForwarderServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/TLS12$", $TLS12)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/LAWorkspaceCount$", $LAWorkspaceCount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/LAWorkspaces$", $LAWorkspaces)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/LAProxyUrl$", $Script:LAProxyUrl)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/LAProxyUsername$", $Script:LAProxyUsername)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ComputerType$", $ComputerType)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/MgmtServerInstallDirectory$", $MgmtServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/MgmtServerURInstallDate$", $MgmtServerURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/MgmtServerVersion$", $MgmtServerVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ConfigServiceAccount$", $ConfigServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ConfigServiceStartMode$", $ConfigServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/DataAccessServiceAccount$", $DataAccessServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/DataAccessServiceStartMode$", $DataAccessServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/OpsDbName$", $OpsDbName)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/OpsDbServer$", $OpsDbServer)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/DWDbName$", $DWDbName)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/DwDbServer$", $DwDbServer)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSCollector$", $ACSCollector)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSCollectorServiceAccount$", $ACSCollectorServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSCollectorServiceStartMode$", $ACSCollectorServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSCollectorURInstallDate$", $ACSCollectorURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ACSCollectorVersion$", $ACSCollectorVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/RMS$", $RMS)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/GatewayServerInstallDirectory$", $GatewayServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/GatewayServerURInstallDate$", $GatewayServerURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/GatewayServerVersion$", $GatewayServerVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/GatewayMGCount$", $GatewayMGCount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/GatewayMGFailovers$", $GatewayMGFailovers)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/WebConsoleInstallDirectory$", $WebConsoleInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/WebConsoleURInstallDate$", $WebConsoleURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/WebConsoleVersion$", $WebConsoleVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/AuthenticationMode$", $AuthenticationMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/DefaultServer$", $DefaultServer)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/WebConsoleUrl$", $WebConsoleUrl)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ApmAdvisorUrl$", $ApmAdvisorUrl)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ApmDiagnosticsUrl$", $ApmDiagnosticsUrl)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerInstallDirectory$", $ReportServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerURInstallDate$", $ReportServerURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerVersion$", $ReportServerVersion)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerDwDbServer$", $ReportServerDwDbServer)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerDWDBName$", $ReportServerDWDBName)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerUrl$", $ReportServerUrl)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/SRSInstance$", $SRSInstance)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerServiceAccount$", $ReportServerServiceAccount)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ReportServerServiceStartMode$", $ReportServerServiceStartMode)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ConsoleInstallDirectory$", $ConsoleInstallDirectory)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ConsoleURInstallDate$", $ConsoleURInstallDate)
$Instance.AddProperty("$MPElement[Name='DXC.PPA.SCOMAdmin.WindowsClass']/ConsoleVersion$", $ConsoleVersion)
$Instance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $ComputerName)
$DiscoveryData.AddInstance($Instance)

# Submit discovery data back to Operations Manager and complete the script.
$DiscoveryData

<# FOR TESTING
$ObjMomApi.Return($DiscoveryData)
#>
LogAndQuit
}
Catch
{
TerminatingError
}
}
GetWindowsInventory -SourceId $SourceId -ManagedEntityId $ManagedEntityId -ComputerName $ComputerName -IgnoreAgentMgmtGroups $IgnoreAgentMgmtGroups -IgnoreGatewayMgmtGroups $IgnoreGatewayMgmtGroups # Need this to pass params in properly.
# End Windows discovery
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>SourceId</Name>
<Value>$MPElement$</Value>
</Parameter>
<Parameter>
<Name>ManagedEntityId</Name>
<Value>$Target/Id$</Value>
</Parameter>
<Parameter>
<Name>ComputerName</Name>
<Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value> <!--removed "Host" 15/7/20. WOW this actually fixed it.-->
</Parameter>
<Parameter>
<Name>IgnoreAgentMgmtGroups</Name>
<Value>$Config/IgnoreAgentMgmtGroups$</Value>
</Parameter>
<Parameter>
<Name>IgnoreGatewayMgmtGroups</Name>
<Value>$Config/IgnoreGatewayMgmtGroups$</Value>
</Parameter>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.Discovery.Data</OutputType>
</DataSourceModuleType>

<!--**************************************** MP BACKUP DATA SOURCE MODULE ****************************************-->

<DataSourceModuleType ID="DXC.PPA.SCOMAdmin.MpBackupDataSourceModule" Accessibility="Public" Batching="false">
<Configuration>
<IncludeSchemaTypes>
<SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
</IncludeSchemaTypes>
<xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="System!System.Scheduler">
<Scheduler>
<SimpleReccuringSchedule>
<Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
<SyncTime>$Config/SyncTime$</SyncTime>
</SimpleReccuringSchedule>
<ExcludeDates />
</Scheduler>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.TriggerData</OutputType>
</DataSourceModuleType>

<!--**************************************** MG REPORT DATA SOURCE MODULE ****************************************-->

<DataSourceModuleType ID="DXC.PPA.SCOMAdmin.MgReportDataSourceModule" Accessibility="Public" Batching="false">
<Configuration>
<IncludeSchemaTypes>
<SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
</IncludeSchemaTypes>
<xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="System!System.Scheduler">
<Scheduler>
<SimpleReccuringSchedule>
<Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
<SyncTime>$Config/SyncTime$</SyncTime>
</SimpleReccuringSchedule>
<ExcludeDates />
</Scheduler>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.TriggerData</OutputType>
</DataSourceModuleType>

<!--**************************************** MP BACKUP WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.MpBackupWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="MpBackupFolder" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="MpBackupFolder" Selector="$Config/MpBackupFolder$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.MpBackup.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start MP Backup
Param ($MpBackupFolder)

<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17613
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17612
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("DXC.PPA.SCOMAdmin.MpBackup.ps1", $EventId, $EventLevel, "Management pack backup script executed.`nWorkflow Name: DXC.PPA.SCOMAdmin.MpBackupRule`nManagement Pack: DXC.PPA.SCOMAdmin.Monitoring (1.0.0.51)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}

<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
} Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}}

<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}

<#**************************************** FUNCTION: MpBackup ****************************************#>
Function MpBackup {
$ErrorActionPreference="Stop"
Try {
<# FOR TESTING
$MpBackupFolder="C:\temp\mpbackups"
#>

<# CODE_SECTION_1
Load required objects.
#>
$CodeSection="1"
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.

<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor

<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.

<# CODE_SECTION_4
Check output folder and load SCOM module.
#>
$CodeSection="4"
If (-Not(Test-Path -Path $MpBackupFolder)) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] The mp backup folder $MpBackupFolder does not exist.`n"
} Else {
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
$ValueToCheck="PowerShellInstallDirectory"; CheckNull $PowerShellInstallDirectory # Expect value.
If ($Script:IsItNull -ne $True) { # 
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$Script:SCOMMGName=(Get-SCOMManagementGroup).Name
$MPs=Get-SCOMManagementPack | Where-Object {$_.Sealed -eq $False}
$MPs | ForEach-Object {
Export-SCOMManagementPack -ManagementPack:$_ -Path:$MpBackupFolder
}}}
LogAndQuit
}
Catch
{
TerminatingError
}
}
MpBackup -MpBackupFolder $MpBackupFolder # Need this to pass params in properly.
# End MP Backup
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>ComputerName</Name>
<Value>$Config/ComputerName$</Value>
</Parameter>
<Parameter>
<Name>MpBackupFolder</Name>
<Value>$Config/MpBackupFolder$</Value>
</Parameter>			  
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** MG REPORT WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.MgReportWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="MgReportFolder" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="MgReportFolder" Selector="$Config/MgReportFolder$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.MgReport.ps1</ScriptName>
<ScriptBody><![CDATA[
<#
notes as neede
#>

# Start MG Report
Param ($MgReportFolder)

<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17615
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17614
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("DXC.PPA.SCOMAdmin.MgReport.ps1", $EventId, $EventLevel, "Management group report script executed.`nWorkflow Name: DXC.PPA.SCOMAdmin.MgReportRule`nManagement Pack: DXC.PPA.SCOMAdmin.Monitoring (1.0.0.51)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}

<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
} Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}}

<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}

<#**************************************** FUNCTION: SQLQuery ****************************************#>
Function SQLQuery ($Script:DbServer,$Script:DbName,$Script:DbQuery) {
$Connection=New-Object System.Data.SQLClient.SQLConnection
$Connection.ConnectionString="Data Source=$DbServer;Database=$DbName;Trusted_Connection=True;"
$Connection.Open()
$Command=New-Object System.Data.SQLClient.SQLCommand
$Command.Connection=$Connection
$Command.CommandText=$DbQuery
$Reader=$Command.ExecuteReader()
$Script:Datatable=New-Object System.Data.DataTable
$Script:Datatable.Load($Reader)
$Connection.Close() 
}

<#**************************************** FUNCTION: MgReport ****************************************#>
Function MgReport {
$ErrorActionPreference="Stop"
Try {
<# FOR TESTING
$Error.Clear()
$MgReportFolder="C:\temp"
#>

<# CODE_SECTION_1
Load things we'll need.
#>
$CodeSection="1"
$Start=(Get-Date -format f) # use this to calculate report generation duration.
$User=[System.Security.Principal.WindowsIdentity]::GetCurrent().Name
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$SetupRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup" # don't do null check on these 4 reg values, the script is running so all good.
$Script:OpsDbName=(Get-ItemProperty $SetupRegKey).DatabaseName
$Script:OpsDbServer=(Get-ItemProperty $SetupRegKey).DatabaseServerName
$Script:DWDbName=(Get-ItemProperty $SetupRegKey).DataWarehouseDBName
$Script:DwDbServer=(Get-ItemProperty $SetupRegKey).DataWarehouseDBServerName

<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor

<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.

<# CODE_SECTION_4
Check output folder and load SCOM module.
#>
$CodeSection="4"
If (-Not(Test-Path -Path $MgReportFolder)) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] The report folder $MgReportFolder does not exist.`n"
} Else {
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
$ValueToCheck="PowerShellInstallDirectory"; CheckNull $PowerShellInstallDirectory # Expect value.
If ($Script:IsItNull -ne $True) {
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$MgName=(Get-SCOMManagementGroup).Name
$ValueToCheck="MgName"; CheckNull $MgName # Expect value.

<# may use later.
$MPs=Get-SCOMManagementPack | Where-Object {$_.Sealed -eq $False}
$MPs | ForEach-Object {
Export-SCOMManagementPack -ManagementPack:$_ -Path:$MgReportFolder
}
#>
}

<# CODE_SECTION_5
Build html/css for report.
#>
$CodeSection="5"
$Head=@"
<style>
h1 {
font-size: 30px;
color: #555555;
}

h2 {
font-size: 20px;
color: #424949;
}

h3 {
font-size: 15px;
color: #555555;
}

h4 {
font-size: 12px;
color: #555555;
}

h1, h2, h3, h4 { /*common settings for h1, h2*/
font-family: Arial;
text-align: left;
}

th {
text-align: center;
font-size: 12px; /*header font size.*/
background-color: gray;
color: white; /*font colour*/
padding: 5px 5px; /*padding */
font-weight: normal; /*remove bold heading*/
}


td {
font-size: 11px; /*row font size.*/
color: #555555;
text-align: left;
padding: 2px 4px; /*This adds more space between columns. 1st digit=row height, 2nd digit=row width.*/
}

table {
white-space:nowrap;
border-collapse: collapse;
border: 1px solid #F2F2F2;
/*width: 100%; /*each table will use x% screen width. Not using.*/
}

th, td { /*common settings for table header and table data.*/
font-family: Arial;
border: 1px solid #F2F2F2;
}

tr:nth-child(even) {background-color: #F2F2F2;}

p {
font-family: Arial;
font-size: 11px;
color: #555555
}

#CreationDate {
font-family: Arial;
color: orange;
font-size: 12px;
}

.Info {
color: #F7F9F9;
background-color: #4CAF50;
text-align: left; /*center text for this column only. Use it?*/
}

.Warning {
color: #555555;
background-color: yellow;
text-align: left; /*center text for this column only. Use it?*/
}

.Error {
color: #F7F9F9;
background-color: #E74C3C;
text-align: left; /*center text for this column only. Use it?*/
}

.btn-group button {
background-color: gray;
font-size: 12px; /*row font size.*/
border: 1px solid gray;
color: white; /* White text */
/*padding: 10px 24px; /* Some padding */
padding: 5px 5px; /* Some padding */
cursor: pointer; /* Pointer/hand icon */
border-radius: 4px;
width:150px; /*remove to auto-size width*/
}

/* Add a background color on hover */
.btn-group button:hover {
background-color: #555555;
}

/*Change to this colour hovering over the index button.*/
a:hover {
color: #555555;
}

.indexbutton{
font-family: Arial;
position:fixed;
/*width:50px;
height:50px;*/
bottom:20px;
right:20px;
background-color:#4CAF50;
color: white;
border-radius:4px;
text-align:center;
box-shadow: 2px 2px 3px #999;
padding: 10px;
text-decoration: none; /*this removes hyperlinks over the text*/
}
</style>
"@
$H2Index="<h2><a id=Index>Index</a></h2>"
$H1SCOMReport="<h1>SCOM Management Group Report</h1>"
$IndexButton="<a href='#Index' class='indexbutton'>Index</a>"
$IndexButtonGroup="<div class='btn-group'; margin-left:100px;>
<a href='#Databases'><button>Databases</button></a>
<a href='#UpdateRollups'><button>Update Rollups</button></a>
</div>"

<# CODE_SECTION_6
Mgmt group summary.
#>
$CodeSection="6"
$DbQuery="SELECT 'SCOM Version' AS Column1,
CASE 
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2012 R2%' then 'Extended support - 2012 R2'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2016%' then '2016'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%180%' then '1801'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2019%' then '2019'
ELSE 'Unknown - ' + MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799
END AS Column2
FROM [$Script:OpsDbName].[dbo].[MTV_DXC`$PPA`$SCOMAdmin`$WindowsClass]
WHERE RMS_771D4202_8806_363E_07CD_678590489569='yes'
UNION ALL
SELECT 'Active Alerts', CAST(CAST(COUNT(*) AS NVARCHAR) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[AlertView]
WHERE ResolutionState != '255'
UNION ALL /* I think this keeps them in current order. */
SELECT 'Windows Agents', CAST(CAST(COUNT(*) AS NVARCHAR) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_HealthService]
WHERE IsAgent='1'
UNION ALL
SELECT 'Unix/Linux Agents', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MTV_Microsoft`$Unix`$Computer]
UNION ALL
SELECT 'Management Servers', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].dbo.MT_Microsoft`$SystemCenter`$CollectionManagementServer
UNION ALL
SELECT 'Gateway Servers', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$SystemCenter`$GatewayManagementServer]
UNION ALL
SELECT 'ACS Collectors', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$SystemCenter`$ACS`$Collector]
UNION ALL
SELECT 'Network Devices', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_System`$NetworkManagement`$Node]
UNION ALL

SELECT 'Broken Health Service',
CASE
WHEN CAST(COUNT(*) AS NVARCHAR) >=1 then 'bad' + CAST(COUNT(*) AS NVARCHAR)
ELSE CAST(COUNT(*) AS NVARCHAR)
END
FROM [$Script:OpsDbName].[dbo].[ManagedEntityGenericView]
WHERE (FullName LIKE '%Microsoft.Unix.Computer:%' AND MonitoringClassId='360E5A02-BC9E-0000-2614-1972E304088A' -- class of the heartbeat alert for unux/linux.
OR FullName LIKE '%Microsoft.SystemCenter.HealthService:%' AND MonitoringClassId='AB4C891F-3359-3FB6-0704-075FBFE36710') -- class of the heartbeat alert for windows.
AND IsAvailable='0'
AND IsDeleted='0'

UNION ALL
SELECT 'Certificates', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MTV_DXC`$PPA`$SCOMAdmin`$WindowsClass]
WHERE CertificateExpiryDate_C6B7EE9B_F90E_4559_9BBD_57C3C54411BF !='n/a'
UNION ALL
SELECT DISTINCT 'Maintenance Mode Jobs', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MaintenanceModeView]
WHERE IsInMaintenanceMode='1'"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$Summary=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h2>Summary</h2>"
$Summary=$Summary -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$Summary=$Summary -replace '<td>Extended support - 2012 R2','<td class="Warning">Extended support - 2012 R2'
$Summary=$Summary -replace '<td>bad','<td class="Warning">'

<# CODE_SECTION_7
OpsDb database summary.
#>
$CodeSection="7"
$DbQuery="SELECT 'Database Name' as Column1, sd.name as Column2 
FROM sys.databases sd where name='$Script:OpsDbName'
UNION ALL
SELECT 'Collation', collation_name FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
SELECT 'Broker enabled',
CASE
WHEN CAST(is_broker_enabled as varchar(10)) = 0 THEN 'ConfigIssue - Disabled' --had to do weird CAST because it's a 'bit' data type.
WHEN CAST(is_broker_enabled as varchar(10)) = 1 THEN 'Yes'
END FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
SELECT 'Full-text enabled',
CASE
WHEN is_fulltext_enabled=0 THEN 'ConfigIssue - Disabled'
WHEN is_fulltext_enabled=1 THEN 'Yes'
END FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
/* removing this, it's too tricky querying 2 sql servers.
SELECT DISTINCT 'Database Server', [OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB] --use distinct in CASE there's 2+ mgmt servers.
FROM [$Script:OpsDbName].[dbo].[MT_DXC`$PPA`$SCOMAdmin`$WindowsClass]
WHERE OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB != 'n/a' --need this else we'll return agents too.
UNION ALL
*/
SELECT 'Clustered',
CASE 
WHEN SERVERPROPERTY('IsClustered') = 0 THEN 'No' 
WHEN SERVERPROPERTY('IsClustered') = 1 THEN 'Yes'
END 
UNION ALL
SELECT 'Last full backup',
CASE
WHEN CAST(max(backup_finish_date)as varchar(50)) is null then 'No backup'
WHEN CAST(max(backup_finish_date)as varchar(50)) < dateadd(day, -7, getdate()) then 'Over 7 days - ' + CAST(max(backup_finish_date)as varchar(50))
ELSE CAST(max(backup_finish_date)as varchar(50))
END
FROM msdb.dbo.backupset
where database_name='$Script:OpsDbName'
AND type='D'"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$OpsDb=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h2><a id=Databases>Databases</a></h2><h3>Operational Database \ Summary</h3>"
$OpsDb=$OpsDb -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$OpsDb=$OpsDb -replace '<td>No backup','<td class="Error">No backup'
$OpsDb=$OpsDb -replace '<td>Over 7 days - ','<td class="Warning">Over 7 days - '
$OpsDb=$OpsDb -replace '<td>ConfigIssue - Disabled','<td class="Error">Disabled'

<# CODE_SECTION_8
OpsDb database file info.
#>
$CodeSection="8"
$DbQuery="USE $Script:OpsDbName
SELECT 
CASE 
WHEN alias_smf.type=0 THEN 'Database'
ELSE 'Log'
END AS 'File Type',
FORMAT(alias_sysfiles.size/128,'N0') + ' MB' as 'File Size',
FORMAT((FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Used Space', 
FORMAT((alias_sysfiles.size/128)-(FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Free Space', 
CASE 
WHEN alias_smf.growth=0 THEN 'Disabled'
ELSE 'Enabled'
END AS 'Autogrow',
alias_smf.physical_name AS 'Filename',
alias_smf.name AS 'Logical Name'
FROM dbo.sysfiles alias_sysfiles
INNER JOIN sys.master_files alias_smf ON alias_sysfiles.filename=alias_smf.physical_name
ORDER BY file_id"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$OpsDbFiles=$Script:Datatable | ConvertTo-Html -Property "File Type", "File Size", "Used Space", "Free Space", "Autogrow", "Filename", "Logical Name" -Fragment -PreContent "<h3>Operational Database \ Db Files</h3>"
$OpsDbFiles=$OpsDbFiles -replace '<td>Disabled','<td class="Error">Disabled'

<# CODE_SECTION_9
DWDb database summary.
#>
$CodeSection="9"
$DbQuery="SELECT 'Database Name' as Column1, sd.name as Column2
FROM sys.databases sd where name='$Script:DWDbName'
UNION ALL
SELECT 'Collation', collation_name FROM sys.databases where name='$Script:DWDbName'
UNION ALL
SELECT 'Broker enabled',
CASE
WHEN CAST(is_broker_enabled as varchar(10)) = 0 THEN 'ConfigIssue - Disabled' --had to do weird CAST because it's a 'bit' data type.
WHEN CAST(is_broker_enabled as varchar(10)) = 1 THEN 'Yes'
END FROM sys.databases where name='$Script:DWDbName'
UNION ALL
SELECT 'Full-text enabled',
CASE
WHEN is_fulltext_enabled=0 THEN 'ConfigIssue - Disabled'
WHEN is_fulltext_enabled=1 THEN 'Yes'
END FROM sys.databases where name='$Script:DWDbName'
UNION ALL
/* removing this, it's too tricky querying 2 sql servers.
SELECT DISTINCT 'Database Server', [OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB] --use distinct in case there's 2+ mgmt servers.
FROM [$Script:OpsDbName].[dbo].[MT_DXC`$PPA`$SCOMAdmin`$WindowsClass]
WHERE OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB != 'n/a' --need this else we'll return agents too.
UNION ALL
*/
SELECT 'Clustered',
CASE 
WHEN SERVERPROPERTY('IsClustered') = 0 THEN 'No' 
WHEN SERVERPROPERTY('IsClustered') = 1 THEN 'Yes'
END 
UNION ALL
SELECT 'Last full backup',
case
when CAST(max(backup_finish_date)as varchar(50)) is null then 'No backup'
when CAST(max(backup_finish_date)as varchar(50)) < dateadd(day, -7, getdate()) then 'Over 7 days - ' + CAST(max(backup_finish_date)as varchar(50))
ELSE CAST(max(backup_finish_date)as varchar(50))
END
FROM msdb.dbo.backupset
where database_name='$Script:DWDbName'
and type='D'" # wrong need to remove this.
SQLQuery $Script:DwDbServer $Script:DWDbName $DbQuery
$DWDb=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h3>Data Warehouse \ Summary</h3>"
$DWDb=$DWDb -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$DWDb=$DWDb -replace '<td>No backup','<td class="Error">No backup'
$DWDb=$DWDb -replace '<td>Over 7 days - ','<td class="Warning">Over 7 days - '
$DWDb=$DWDb -replace '<td>ConfigIssue - Disabled','<td class="Error">Disabled'

<# CODE_SECTION_10
DWDb database file info.
#>
$CodeSection="10"
$DbQuery="USE $Script:DWDbName
SELECT 
CASE 
WHEN alias_smf.type=0 THEN 'Database'
ELSE 'Log'
END AS 'File Type',
FORMAT(alias_sysfiles.size/128,'N0') + ' MB' as 'File Size',
FORMAT((FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Used Space', 
FORMAT((alias_sysfiles.size/128)-(FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Free Space', 
CASE 
WHEN alias_smf.growth=0 THEN 'Disabled'
ELSE 'Enabled'
END AS 'Autogrow',
alias_smf.physical_name AS 'Filename',
alias_smf.name AS 'Logical Name'
FROM dbo.sysfiles alias_sysfiles
INNER JOIN sys.master_files alias_smf ON alias_sysfiles.filename=alias_smf.physical_name
ORDER BY file_id"
SQLQuery $Script:DwDbServer $Script:DWDbName $DbQuery
$DWDbFiles=$Script:Datatable | ConvertTo-Html -Property "File Type", "File Size", "Used Space", "Free Space", "Autogrow", "Filename", "Logical Name" -Fragment -PreContent "<h3>Data Warehouse \ Db Files</h3>"
$DWDbFiles=$DWDbFiles -replace '<td>Disabled','<td class="Error">Disabled'

<# CODE_SECTION_10
?
#>
$CodeSection="10"

<# CODE_SECTION_11
Update rollup info.
#>
$CodeSection="11"
$DbQuery="SELECT UPPER (DisplayName) As Computer
,AgentVersion_3AFB8DF2_255D_EF64_2996_AB381CA83F11 AS Agent
,[MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799] AS ManagementServer
,[WebConsoleVersion_6EC692DE_61A1_190E_D016_A6D8039081C2] AS WebConsole
,[ReportServerVersion_A9D4505D_ADFE_5CF2_7E23_FFFC0ED131EB] AS ReportServer
,[GatewayServerVersion_C5C64EC6_1FAE_82EB_90BF_37D55CB4FF69] AS GatewayServer
,[ACSCollectorVersion_D788AA22_33A3_C547_BF37_5571B8416756] AS ACSCollector
,[ConsoleVersion_B993C88D_FD4E_DA45_4CD9_ABB39B7890CD] AS UIConsole
FROM [$Script:OpsDbName].[dbo].[MT_DXC`$PPA`$SCOMAdmin`$WindowsClass]
ORDER BY Computer ASC"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$UpdateRollups=$Script:Datatable | Select-Object Computer,Agent,@{N='Management Server';E={$_.ManagementServer}},@{N='Web Console';E={$_.WebConsole}},@{N='Report Server';E={$_.ReportServer}},@{N='Gateway Server';E={$_.GatewayServer}},@{N='ACS Collector';E={$_.ACSCollector}},@{N='UI Console';E={$_.UIConsole}} | ConvertTo-Html -Property Computer, Agent,"Management Server","Web Console","Report Server","ACS Collector","Gateway Server","UI Console" -Fragment -PreContent "<h2><a id=UpdateRollups>Update Rollups</a></h2>"
$UpdateRollups=$UpdateRollups -replace '<td>Unknown version','<td class="Error">Unknown version'
$UpdateRollups=$UpdateRollups -replace '<td>Update required','<td class="Warning">Update required'

<# CODE_SECTION_10
Finish generating report.
#>
$CodeSection="10"
$GenerationTime="<p>This report was generated on $ComputerFqdn by $User on $Start.</p>"
ConvertTo-HTML -Head $Head -Body "$H1SCOMReport $GenerationTime $H2Index $IndexButtonGroup $Summary $OpsDb $OpsDbFiles $DWDb $DWDbFiles $UpdateRollups $ExampleParagraph $IndexButton" | Out-File "$MgReportFolder\$MgName`_SCOM_Report.html"

<# FOR TESTING
Invoke-Item -Path "$MgReportFolder\$MgName`_SCOM_Report.html" # remove when done.
#>
} # end test report path.
LogAndQuit
}
Catch
{
TerminatingError
}
}
MgReport -MgReportFolder $MgReportFolder # Need this to pass params in properly.
# End MG Report
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>ComputerName</Name>
<Value>$Config/ComputerName$</Value>
</Parameter>
<Parameter>
<Name>MgReportFolder</Name>
<Value>$Config/MgReportFolder$</Value>
</Parameter>			  
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** GET LOG ANALYTICS WORKSPACES WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.GetLogAnalyticsWorkspaceWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.GetLogAnalyticsWorkspaceWriteActionModule.ps1</ScriptName>
<ScriptBody><![CDATA[
Function FoundNone {
$Script:Output="No Log Analytics workspaces found."
}

Function GetLAWorkspaces {
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get Log Analytics workspaces"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
$LAWorkspaceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\Service Connector Services"
If (Test-Path $LAWorkspaceRegKey) {
$BindLAWorkspaceRegKey=Get-Item $LAWorkspaceRegKey
$LAWorkspaceCount=($BindLAWorkspaceRegKey).SubKeyCount
If ($LAWorkspaceCount -gt 0) {
$ArrayLAWorkspaces=$BindLAWorkspaceRegKey.GetSubKeyNames()
$ArrayLAWorkspaces | ForEach-Object {
$LAWorkspaceId=$_.Substring(16)
$LAWorkspaceTypeId=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Azure Cloud Type"
Switch ($LAWorkspaceTypeId) {
"0" {$LAWorkspaceType="Azure Commercial"; BREAK}
"1" {$LAWorkspaceType="Azure US Government"; BREAK}
"2" {$LAWorkspaceType="Azure China"; BREAK}
"3" {$LAWorkspaceType="Azure US Nat"; BREAK}
"4" {$LAWorkspaceType="Azure US Sec"; BREAK}
Default {
$LAWorkspaceType="Unknown"
}
}
$LAWorkspaceConnectionStatusId=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Connection Status"
If ($LAWorkspaceConnectionStatusId -eq 0) {
$LAWorkspaceConnectionStatus="Connected"
}
Else {
$LAWorkspaceConnectionStatus="Unknown"
}
$Output+="Workspace Id: $LAWorkspaceId`nCloud Type: $LAWorkspaceTypeId ($LAWorkspaceType)`nConnection Status: $LAWorkspaceConnectionStatusId ($LAWorkspaceConnectionStatus)`n`n"
} # END FOR
}
Else {
FoundNone
}
}
Else {
FoundNone
}
Write-Host $Output
}
GetLAWorkspaces
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** GET TLS1.2 REGISTRY WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.GetTLSRegSettingsWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.GetTLSRegSettingsWriteActionModule.ps1</ScriptName>
<ScriptBody><![CDATA[
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:Message+="[WARNING] Missing value name: $_\$ValueToCheck`n"
}
Else {
$Script:Message+="[INFO] Found value: $_\$ValueToCheck=$PassedInParam`n"
}
}
Function RunScript {
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get TLS1.2 registry settings"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
$ArrayTLS12NETEnabled="HKLM:\SOFTWARE\Microsoft\.NETFramework\v4.0.30319","HKLM:\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319"
$ArrayTLS12NETEnabled | ForEach-Object {
$Count+=1
If (Test-Path -Path $_) {
$SchUseStrongCrypto=(Get-ItemProperty $_).SchUseStrongCrypto
}
$ValueToCheck="SchUseStrongCrypto"; CheckNull $SchUseStrongCrypto
}
$ArrayTLS12OSRegKey="HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client","HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Server"
$ArrayTLS12OSRegKey | ForEach-Object {
If (Test-Path -Path $_) {
$Enabled=(Get-ItemProperty $_).Enabled
$DisabledByDefault=(Get-ItemProperty $_).DisabledByDefault
}
$ValueToCheck="Enabled"; CheckNull $Enabled
$ValueToCheck="DisabledByDefault"; CheckNull $DisabledByDefault
}
$Script:Message
}
RunScript
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** GET WINDOWS SERVICES WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.GetWindowsServicesWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.GetWindowsServicesWriteActionModule.ps1</ScriptName>
<ScriptBody><![CDATA[
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get Windows services"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
Write-Host "Note: Services have been sorted by the DisplayName property."
Write-Host
$Services=Get-CimInstance -ClassName Win32_Service | Sort-Object DisplayName | Select-Object -Property DisplayName,Name,State,StartMode,StartName,ProcessId
$Services | ForEach-Object {
$DisplayName=$_.DisplayName
$Name=$_.Name
$State=$_.State
$StartMode=$_.StartMode
$StartName=$_.StartName
$ProcessId=$_.ProcessId
$Output+="DISPLAY_NAME: $DisplayName`nSERVICE_NAME: $Name`nSTATUS: $State`nStartMode_TYPE: $StartMode`nLOG_ON_ACCOUNT: $StartName`nPROCESS_ID: $ProcessId`n`n"
}
$Output
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** GET WINDOWS DISK VOLUMES WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="DXC.PPA.SCOMAdmin.GetWindowsDiskInfoWriteActionModule" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>DXC.PPA.SCOMAdmin.GetWindowsDiskInfoWriteActionModule.ps1</ScriptName>
<ScriptBody><![CDATA[
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get disk info"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
Set-Variable -Name "CONVERSION_FACTOR" -Value "1073741824"
Set-Variable -Name "FIXED_DISK" -Value "3"
$Volumes=Get-CimInstance -ClassName Win32_Volume | Where-Object DriveType -eq $FIXED_DISK | Sort-Object Name
$Volumes | ForEach-Object {
$Name=$_.Name
$Label=$_.Label
$DriveType=$_.DriveType
Switch ($DriveType) {
"0" {$DriveType="Unknown"; BREAK}
"1" {$DriveType="No Root Directory"; BREAK}
"2" {$DriveType="Removable Disk"; BREAK}
"3" {$DriveType="Local Disk"; BREAK}
"4" {$DriveType="Network Drive"; BREAK}
"5" {$DriveType="Compact Disc"; BREAK}
"6" {$DriveType="RAM Disk"; BREAK}
Default {$DriveType="Unknown"}
}
$FileSystem=$_.FileSystem
$VolumeCapacity="{0:n2}" -f ($_.Capacity / $CONVERSION_FACTOR)
$VolumeUsedSpace="{0:n2}" -f (($_.Capacity - $_.FreeSpace) / $CONVERSION_FACTOR)
$VolumeFreeSpace="{0:n2}" -f ($_.FreeSpace / $CONVERSION_FACTOR)
$DirtyBitSet=$_.DirtyBitSet
$Output+="VOLUME_NAME: $Name`nVOLUME_LABEL: $Label`nDRIVE_TYPE: $DriveType`nFILE_SYSTEM: $FileSystem`nCAPACITY: $VolumeCapacity GB`nUSED_SPACE: $VolumeUsedSpace GB`nFREE_SPACE: $VolumeFreeSpace GB`nDIRTY_BIT_SET: $DirtyBitSet   `n`n"
}
$Output
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

<!--**************************************** RESET AGENT HEALTH WRITE ACTION MODULE ****************************************-->

<WriteActionModuleType ID="Microsoft.SystemCenter.ResetServiceStoreAction" Comment="Request Health Service Store Reset" Accessibility="Internal" Batching="false">
<Configuration />
<ModuleImplementation Isolation="Any">
<Native>
<ClassID>B253A4FA-71BE-4F5D-94D5-A46B0D2505AA</ClassID>
</Native>
</ModuleImplementation>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>

</ModuleTypes>
</TypeDefinitions>

<!--**************************************** RUN BUILT-IN TASKS ****************************************-->

<Categories>
<Category ID="DXC.PPA.SCOMAdmin.CategoryPingTask" Target="DXC.PPA.SCOMAdmin.PingTask" Value="System!System.Internal.ManagementPack.ConsoleTasks.MonitoringObject" />
<Category ID="DXC.PPA.SCOMAdmin.CategoryRDPTask" Target="DXC.PPA.SCOMAdmin.RDPTask" Value="System!System.Internal.ManagementPack.ConsoleTasks.MonitoringObject" />
</Categories>

<Monitoring>

<!--**************************************** DISCOVERIES ****************************************-->

<Discoveries>
<Discovery ID="DXC.PPA.SCOMAdmin.WindowsPowerShellDiscovery" Target="Windows!Microsoft.Windows.Computer" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
<Category>Discovery</Category>
<DiscoveryTypes>
<DiscoveryClass TypeID="DXC.PPA.SCOMAdmin.WindowsClass">
<Property PropertyID="OperatingSystem"/>
<Property PropertyID="Product"/>
<Property PropertyID="AgentInstallDirectory"/>
<Property PropertyID="AgentURInstallDate"/>
<Property PropertyID="AgentVersion"/>
<Property PropertyID="AgentMGCount"/>
<Property PropertyID="AgentMGFailovers"/>
<Property PropertyID="HealthServiceAccount"/>
<Property PropertyID="HealthServiceStartMode"/>
<Property PropertyID="CertificateExpiryDate"/>
<Property PropertyID="ADIntegration"/>
<Property PropertyID="APMInstalled"/>
<Property PropertyID="APMServiceAccount"/>
<Property PropertyID="APMServiceStartMode"/>
<Property PropertyID="ACSForwarderServiceAccount"/>
<Property PropertyID="ACSForwarderServiceStartMode"/>
<Property PropertyID="TLS12"/>
<Property PropertyID="LAWorkspaceCount"/>
<Property PropertyID="LAWorkspaces"/>
<Property PropertyID="LAProxyUrl"/>
<Property PropertyID="LAProxyUsername"/>
<Property PropertyID="ComputerType"/>
<Property PropertyID="MgmtServerInstallDirectory"/>
<Property PropertyID="MgmtServerURInstallDate"/>
<Property PropertyID="MgmtServerVersion"/>
<Property PropertyID="ConfigServiceAccount"/>
<Property PropertyID="ConfigServiceStartMode"/>
<Property PropertyID="DataAccessServiceAccount"/>
<Property PropertyID="DataAccessServiceStartMode"/>
<Property PropertyID="OpsDbName"/>
<Property PropertyID="OpsDbServer"/>
<Property PropertyID="DWDbName"/>
<Property PropertyID="DwDbServer"/>
<Property PropertyID="ACSCollector"/>
<Property PropertyID="ACSCollectorServiceAccount"/>
<Property PropertyID="ACSCollectorServiceStartMode"/>
<Property PropertyID="ACSCollectorURInstallDate"/>
<Property PropertyID="ACSCollectorVersion"/>
<Property PropertyID="RMS"/>
<Property PropertyID="GatewayServerInstallDirectory"/>
<Property PropertyID="GatewayServerURInstallDate"/>
<Property PropertyID="GatewayServerVersion"/>
<Property PropertyID="GatewayMGCount"/>
<Property PropertyID="GatewayMGFailovers"/>
<Property PropertyID="WebConsoleInstallDirectory"/>
<Property PropertyID="WebConsoleURInstallDate"/>
<Property PropertyID="WebConsoleVersion"/>
<Property PropertyID="AuthenticationMode"/>
<Property PropertyID="DefaultServer"/>
<Property PropertyID="WebConsoleUrl"/>
<Property PropertyID="ApmAdvisorUrl"/>
<Property PropertyID="ApmDiagnosticsUrl"/>
<Property PropertyID="ReportServerInstallDirectory"/>
<Property PropertyID="ReportServerURInstallDate"/>
<Property PropertyID="ReportServerVersion"/>
<Property PropertyID="ReportServerDwDbServer"/>
<Property PropertyID="ReportServerDWDBName"/>
<Property PropertyID="ReportServerUrl"/>
<Property PropertyID="SRSInstance"/>
<Property PropertyID="ReportServerServiceAccount"/>
<Property PropertyID="ReportServerServiceStartMode"/>
<Property PropertyID="ConsoleInstallDirectory"/>
<Property PropertyID="ConsoleURInstallDate"/>
<Property PropertyID="ConsoleVersion"/>
</DiscoveryClass>
</DiscoveryTypes>
<DataSource ID="DS" TypeID="DXC.PPA.SCOMAdmin.WindowsDiscoveryDataSourceModule">
<IntervalSeconds>3600</IntervalSeconds> <!--REMEMBER TO CHANGE THIS!!!!!!!!!!!!!-->
<SyncTime></SyncTime>
<TimeoutSeconds>120</TimeoutSeconds>
<IgnoreAgentMgmtGroups></IgnoreAgentMgmtGroups> <!--Don't put anything here else it will get passed in.-->
<IgnoreGatewayMgmtGroups></IgnoreGatewayMgmtGroups> <!--Don't put anything here else it will get passed in.-->
</DataSource>
</Discovery>
</Discoveries>

<!--**************************************** RULES ****************************************-->
<Rules>
<!--Mp backup rule-->
<Rule ID="DXC.PPA.SCOMAdmin.MpBackupRule" Enabled="false" Target="DXC.PPA.SCOMAdmin.WindowsClass" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
<DataSource ID="Scheduler" TypeID="DXC.PPA.SCOMAdmin.MpBackupDataSourceModule">
<IntervalSeconds>3600</IntervalSeconds> <!--REMEMBER TO CHANGE THIS!!!!!!!!!!!!!-->
<SyncTime></SyncTime>
</DataSource>	  
</DataSources>		
<WriteActions>
<WriteAction ID="WA" TypeID="DXC.PPA.SCOMAdmin.MpBackupWriteActionModule">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<MpBackupFolder></MpBackupFolder> <!--LEAVE BLANK-->
<TimeoutSeconds>120</TimeoutSeconds>
</WriteAction>
</WriteActions>
</Rule>

<!--Mg report rule-->
<Rule ID="DXC.PPA.SCOMAdmin.MgReportRule" Enabled="false" Target="DXC.PPA.SCOMAdmin.WindowsClass" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
<DataSource ID="Scheduler" TypeID="DXC.PPA.SCOMAdmin.MgReportDataSourceModule">
<IntervalSeconds>3600</IntervalSeconds> <!--REMEMBER TO CHANGE THIS!!!!!!!!!!!!!-->
<SyncTime></SyncTime>
</DataSource>	  
</DataSources>		
<WriteActions>
<WriteAction ID="WA" TypeID="DXC.PPA.SCOMAdmin.MgReportWriteActionModule">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<MgReportFolder></MgReportFolder> <!--LEAVE BLANK-->
<TimeoutSeconds>120</TimeoutSeconds>
</WriteAction>
</WriteActions>
</Rule>

</Rules>

<!--**************************************** TASKS ****************************************-->
<Tasks>
<!--Get log analytics workspaces-->
<Task ID="DXC.PPA.SCOMAdmin.GetLogAnalyticsWorkspaceTask" Accessibility="Public" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="DXC.PPA.SCOMAdmin.GetLogAnalyticsWorkspaceWriteActionModule">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>

<!--Get TLS reg setting-->
<Task ID="DXC.PPA.SCOMAdmin.GetTLSRegSettingsTask" Accessibility="Public" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="DXC.PPA.SCOMAdmin.GetTLSRegSettingsWriteActionModule">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>

<!--Get windows services-->
<Task ID="DXC.PPA.SCOMAdmin.GetWindowsServicesTask" Accessibility="Public" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="DXC.PPA.SCOMAdmin.GetWindowsServicesWriteActionModule">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>

<!--Get windows services-->
<Task ID="DXC.PPA.SCOMAdmin.GetWindowsDiskInfoTask" Accessibility="Public" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="DXC.PPA.SCOMAdmin.GetWindowsDiskInfoWriteActionModule">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>

<!--Reset health-->
<Task ID="DXC.PPA.SCOMAdmin.ResetHealthTask" Comment="Request Health Service Store Reset" Accessibility="Internal" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" Timeout="300" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="ResetServiceStore" TypeID="Microsoft.SystemCenter.ResetServiceStoreAction" />
</Task>

</Tasks>

<!--**************************************** MONITORS ****************************************-->

<Monitors>
<UnitMonitor ID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitor" Accessibility="Public" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>
<AlertSettings AlertMessage="DXC.PPA.SCOMAdmin.WindowsInventoryMonitorAlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17611</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17610</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>

<UnitMonitor ID="DXC.PPA.SCOMAdmin.MpBackupMonitor" Accessibility="Public" Enabled="false" Target="DXC.PPA.SCOMAdmin.WindowsClass" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>
<AlertSettings AlertMessage="DXC.PPA.SCOMAdmin.MpBackupMonitorAlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17613</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17612</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>

<UnitMonitor ID="DXC.PPA.SCOMAdmin.MgReportMonitor" Accessibility="Public" Enabled="false" Target="DXC.PPA.SCOMAdmin.WindowsClass" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>
<AlertSettings AlertMessage="DXC.PPA.SCOMAdmin.MgReportMonitorAlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17615</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17614</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>
</Monitors>

<!--<Overrides>
</Overrides>
-->

</Monitoring>
<Presentation>

<!--**************************************** CONSOLE TASKS ****************************************-->

<ConsoleTasks>
<ConsoleTask ID="DXC.PPA.SCOMAdmin.PingTask" Accessibility="Internal" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" RequireOutput="true">
<Assembly>Resource.DXC.PPA.SCOMAdmin.PingTask</Assembly>
<Handler>ShellHandler</Handler>
<Parameters>
<Argument Name="WorkingDirectory" />
<Argument Name="Application">%windir%\system32\ping.exe</Argument>
<Argument>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Argument>
</Parameters>
</ConsoleTask>

<ConsoleTask ID="DXC.PPA.SCOMAdmin.RDPTask" Accessibility="Internal" Enabled="true" Target="DXC.PPA.SCOMAdmin.WindowsClass" RequireOutput="false">
<Assembly>Resource.DXC.PPA.SCOMAdmin.RDPTask</Assembly>
<Handler>ShellHandler</Handler>
<Parameters>
<Argument Name="WorkingDirectory" />
<Argument Name="Application">%windir%\system32\mstsc.exe</Argument>
<Argument>/v:</Argument>
<Argument>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$ /f</Argument>
</Parameters>
</ConsoleTask>
</ConsoleTasks>

<StringResources>
<StringResource ID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitorAlertMessage" />
<StringResource ID="DXC.PPA.SCOMAdmin.MpBackupMonitorAlertMessage" />
<StringResource ID="DXC.PPA.SCOMAdmin.MgReportMonitorAlertMessage" />
</StringResources>
</Presentation>
<LanguagePacks>
<LanguagePack ID="ENU" IsDefault="true">
<DisplayStrings>

<!--**************************************** MANAGEMENT PACK ****************************************-->

<DisplayString ElementID="DXC.PPA.SCOMAdmin.Monitoring">
<Name>DXC PPA SCOM Admin Monitoring</Name>
<Description>Tools to help you manage SCOM. Created by the Workplace and Mobility monitoring team.</Description>
</DisplayString>

<!--Windows class-->
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass">
<Name>DXC PPA SCOM Admin Windows Class</Name>
<Description></Description>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="OperatingSystem">
<Name>Operating System</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="Product">
<Name>Product</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AgentInstallDirectory">
<Name>Agent Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AgentURInstallDate">
<Name>Agent UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AgentVersion">
<Name>Agent Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AgentMGCount">
<Name>Agent MG Count</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AgentMGFailovers">
<Name>Agent MG Failovers</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="HealthServiceAccount">
<Name>Health Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="HealthServiceStartMode">
<Name>Health Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="CertificateExpiryDate">
<Name>Certificate Expiry Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ADIntegration">
<Name>AD Integration</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="APMInstalled">
<Name>APM Installed</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="APMServiceAccount">
<Name>APM Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="APMServiceStartMode">
<Name>APM Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSForwarderServiceAccount">
<Name>ACS Forwarder Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSForwarderServiceStartMode">
<Name>ACS Forwarder Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="TLS12">
<Name>TLS 1.2</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="LAWorkspaceCount">
<Name>LA Workspace Count</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="LAWorkspaces">
<Name>LA Workspaces</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="LAProxyUrl">
<Name>LA ProxyUrl</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="LAProxyUsername">
<Name>LA Proxy Username</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ComputerType">
<Name>Computer Type</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="MgmtServerInstallDirectory">
<Name>Mgmt Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="MgmtServerURInstallDate">
<Name>Mgmt Server UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="MgmtServerVersion">
<Name>Mgmt Server Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ConfigServiceAccount">
<Name>Config Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ConfigServiceStartMode">
<Name>Config Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="DataAccessServiceAccount">
<Name>Data Access Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="DataAccessServiceStartMode">
<Name>Data Access Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="OpsDbName">
<Name>Operations Manager Database Name</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="OpsDbServer">
<Name>Operations Manager Database Server</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="DWDbName">
<Name>Data Warehouse Database Name</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="DwDbServer">
<Name>Data Warehouse Database Server</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSCollector">
<Name>ACS Collector</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSCollectorServiceAccount">
<Name>ACS Collector Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSCollectorServiceStartMode">
<Name>ACS Collector Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSCollectorURInstallDate">
<Name>ACS Collector UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ACSCollectorVersion">
<Name>ACS Collector Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="RMS">
<Name>RMS</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="GatewayServerInstallDirectory">
<Name>Gateway Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="GatewayServerURInstallDate">
<Name>Gateway Server UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="GatewayServerVersion">
<Name>Gateway Server Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="GatewayMGCount">
<Name>Gateway MG Count</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="GatewayMGFailovers">
<Name>Gateway MG Failovers</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="WebConsoleInstallDirectory">
<Name>Web Console Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="WebConsoleURInstallDate">
<Name>Web Console UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="WebConsoleVersion">
<Name>Web Console Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="AuthenticationMode">
<Name>Authentication Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="DefaultServer">
<Name>Default Server</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="WebConsoleUrl">
<Name>Web Console Url</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ApmAdvisorUrl">
<Name>Apm Advisor Url</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ApmDiagnosticsUrl">
<Name>Apm Diagnostics Url</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerInstallDirectory">
<Name>Report Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerServiceAccount">
<Name>Report Server Service Account</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerServiceStartMode">
<Name>Report Server Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerURInstallDate">
<Name>Report Server UR Install Date (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerVersion">
<Name>Report Server Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerDwDbServer">
<Name>Data Warehouse Database Server</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerDWDBName">
<Name>Data Warehouse Database Name</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ReportServerUrl">
<Name>Report Server Url</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="SRSInstance">
<Name>SRS Instance</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ConsoleVersion">
<Name>Console Version</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ConsoleInstallDirectory">
<Name>Console Install Directory</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsClass" SubElementID="ConsoleURInstallDate">
<Name>Console UR Install Date (YMDT)</Name>
</DisplayString>

<!--Discoveries-->
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsPowerShellDiscovery">
<Name>DXC PPA SCOM Admin Windows PowerShell Discovery</Name>
<Description>This script gets the properties of class 'DXC.PPA.SCOMAdmin.WindowsClass'.</Description>
</DisplayString>

<!--Rules-->
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MpBackupRule">
<Name>DXC PPA SCOM Admin MpBackup Rule</Name>
<Description />
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.MgReportRule">
<Name>DXC PPA SCOM Admin MgReport Rule</Name>
<Description />
</DisplayString>

<!--Monitors-->
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitor">
<Name>DXC PPA SCOM Admin Windows Inventory</Name>
<Description>add later</Description>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitor" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitor" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitorAlertMessage">
<Name>Windows inventory</Name>
<Description>{0}</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.MpBackupMonitor">
<Name>DXC PPA SCOM Admin Mp Backup</Name>
<Description>add later</Description>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MpBackupMonitor" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MpBackupMonitor" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MpBackupMonitorAlertMessage">
<Name>Management pack backup failed</Name>
<Description>{0}</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.MgReportMonitor">
<Name>DXC PPA SCOM Admin Mg Report</Name>
<Description>add later</Description>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MgReportMonitor" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MgReportMonitor" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="DXC.PPA.SCOMAdmin.MgReportMonitorAlertMessage">
<Name>Management group report failed</Name>
<Description>{0}</Description>
</DisplayString>

<!--Tasks-->
<DisplayString ElementID="DXC.PPA.SCOMAdmin.GetLogAnalyticsWorkspaceTask">
<Name>Get Log Analytics workspaces</Name>
<Description>This task shows information about Log Analytics workspaces configured on the computer.</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.GetTLSRegSettingsTask">
<Name>Get TLS 1.2 registry settings</Name>
<Description>This task shows information about Windows services.</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.GetWindowsServicesTask">
<Name>Get services</Name>
<Description>This task shows the state of the registry settings required for TLS 1.2.</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.GetWindowsDiskInfoTask">
<Name>Get disk info</Name>
<Description>This task shows information about fixed disks i.e. used/free space.</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.ResetHealthTask">
<Name>Flush Cache</Name>
<Description>WARNING: Only run this task on agents. Do not run it on management servers or gateway servers.

This task will reset all state in the Health Service. This includes the state of rules, monitors, outgoing data, and cached management packs.  Since this task will reset the service, status of this task will not be delivered since outgoing task status is part of what is reset by this task. A warning event with Id 103 is logged to the Operations Manager log.</Description>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.PingTask">
<Name>Ping</Name>
</DisplayString>

<DisplayString ElementID="DXC.PPA.SCOMAdmin.RDPTask">
<Name>RDP</Name>
</DisplayString>

</DisplayStrings>

<KnowledgeArticles>
<KnowledgeArticle ElementID="DXC.PPA.SCOMAdmin.Monitoring" Visible="true">
<MamlContent>
<maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
<maml:title>Test - Title</maml:title>
<maml:para>Line 1</maml:para>
<maml:para>Line 2</maml:para>
<maml:list>
<maml:listItem>
<maml:para>Bullet Point 1</maml:para>
</maml:listItem>
<maml:listItem>
<maml:para>Bullet Point 2</maml:para>
</maml:listItem>
<maml:listItem>
<maml:para>Bullet Point 3</maml:para>
</maml:listItem>
</maml:list>
</maml:section>
</MamlContent>
</KnowledgeArticle>
<KnowledgeArticle ElementID="DXC.PPA.SCOMAdmin.WindowsInventoryMonitor" Visible="true">
<MamlContent>
<maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
<maml:title>Test - Monitor</maml:title>
<maml:para>Line 1</maml:para>
<maml:para>Line 2</maml:para>
</maml:section>
</MamlContent>
</KnowledgeArticle>
</KnowledgeArticles>
</LanguagePack>
</LanguagePacks>
<Resources>
<Assembly ID="Resource.DXC.PPA.SCOMAdmin.PingTask" Accessibility="Public" FileName="DXC.PPA.SCOMAdmin.PingTask" HasNullStream="true" QualifiedName="DXC.PPA.SCOMAdmin.PingTask" />
<Assembly ID="Resource.DXC.PPA.SCOMAdmin.RDPTask" Accessibility="Public" FileName="DXC.PPA.SCOMAdmin.RDPTask" HasNullStream="true" QualifiedName="DXC.PPA.SCOMAdmin.RDPTask" />
</Resources>
</ManagementPack>